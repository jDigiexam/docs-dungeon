<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>8-Bit Office Mystery</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            overscroll-behavior: none;
            touch-action: none;
        }
        /* Hide scrollbars */
        ::-webkit-scrollbar {
            display: none;
        }
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */

        #remote-videos-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen flex flex-col md:flex-row items-stretch">

    <!-- UI Panel (Left Side on Desktop, Bottom on Mobile) -->
    <div id="ui-panel" class="w-full md:w-72 lg:w-96 bg-gray-800 p-4 flex flex-col space-y-2 overflow-y-auto order-last md:order-first h-1/3 md:h-full">
        <!-- Status -->
        <div id="status-text" class="text-lg bg-gray-900/50 p-2 rounded">Status: Alive</div>
        
        <!-- Video Streams -->
        <div class="flex space-x-2">
            <div class="w-1/2 relative aspect-square">
                <video id="local-video" autoplay muted playsinline class="w-full h-full object-cover bg-gray-700 rounded-md border-2 border-gray-500"></video>
                <div id="local-video-overlay" class="absolute inset-0 flex items-center justify-center bg-black/50 text-xs font-bold">YOU</div>
            </div>
            <div id="remote-videos-container" class="w-1/2 bg-gray-700 rounded-md flex items-center justify-center text-sm relative overflow-hidden aspect-square">
                <span id="remote-video-placeholder">Teammate</span>
            </div>
        </div>

         <!-- Video Controls -->
        <div class="flex justify-center space-x-4">
            <button id="toggle-mic-btn" class="p-3 bg-red-600 rounded-full hover:bg-red-500 text-white transition-colors">
                <svg id="mic-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                </svg>
                <svg id="mic-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M5 5l14 14" />
                </svg>
            </button>
            <button id="toggle-cam-btn" class="p-3 bg-red-600 rounded-full hover:bg-red-500 text-white transition-colors">
                <svg id="cam-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                     <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                </svg>
                <svg id="cam-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                   <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                   <path stroke-linecap="round" stroke-linejoin="round" d="M5 5l14 14" />
                </svg>
            </button>
        </div>

        <!-- Chat Box -->
        <div class="flex flex-col flex-grow min-h-0">
             <div id="chat-box" class="flex-grow bg-black/60 rounded-md p-2 overflow-y-auto text-sm mb-2">
                <div id="chat-messages"></div>
            </div>
            <input id="chat-input" type="text" placeholder="Type a message..." class="w-full bg-gray-700 border-2 border-gray-500 rounded-md p-2 text-sm">
        </div>
    </div>

    <!-- Main Game Container -->
    <div id="game-container" class="relative flex-grow bg-black shadow-lg rounded-lg overflow-hidden">
        
        <!-- Loading Screen -->
        <div id="loading-screen" class="absolute inset-0 bg-gray-900/80 z-50 flex flex-col items-center justify-center">
            <h1 class="text-4xl mb-4">Office Mystery</h1>
            <p id="loading-text">Connecting...</p>
        </div>

        <!-- Lobby Screen (Initially hidden) -->
        <div id="lobby-screen" class="hidden absolute inset-0 bg-gray-800 z-40 p-8 flex flex-col items-center justify-center text-center">
            <h2 class="text-3xl mb-6">Game Lobby</h2>
            <input id="username-input" type="text" placeholder="Enter Your Name" class="bg-gray-700 border-2 border-gray-500 rounded-md p-3 text-lg mb-4 w-full max-w-sm text-center">
            <button id="join-game-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-md text-xl">Join Game</button>
        </div>
        
        <!-- Game Screen -->
        <div id="game-screen" class="relative w-full h-full">
            <canvas id="game-canvas" class="w-full h-full"></canvas>

            <!-- Virtual Joystick for Mobile -->
            <div id="joystick-container" class="absolute bottom-10 right-10 w-32 h-32 rounded-full bg-gray-500/30 flex items-center justify-center select-none md:hidden">
                <div id="joystick-thumb" class="w-16 h-16 rounded-full bg-gray-400/50"></div>
            </div>
        </div>
    </div>

    <!-- Supabase and Game Logic -->
    <script type="module">
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // --- 1. CONFIGURATION ---
        const SUPABASE_URL = 'https://uypjowqnnostwxmcflnm.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV5cGpvd3Fubm9zdHd4bWNmbG5tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAwMTg3NjksImV4cCI6MjA3NTU5NDc2OX0.iUDDwG-TXg5AZNdXxKViz9JomSGtUgiwGnKcs7GBnaU';

        // --- 2. SUPABASE & REALTIME SETUP ---
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        const GAME_CHANNEL = 'office-mystery-game';
        const channel = supabase.channel(GAME_CHANNEL, { config: { broadcast: { self: true } } });

        // --- 3. DOM ELEMENTS & GAME STATE ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loading-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const joinGameBtn = document.getElementById('join-game-btn');
        const usernameInput = document.getElementById('username-input');
        const chatInput = document.getElementById('chat-input');

        const gameState = {
            players: {},
            clues: [],
            monsterId: null,
        };
        let myPlayerId = Math.random().toString(36).substring(7);

        // --- 4. WEBRTC & MEDIA ---
        const localVideo = document.getElementById('local-video');
        const remoteVideosContainer = document.getElementById('remote-videos-container');
        const remoteVideoPlaceholder = document.getElementById('remote-video-placeholder');
        const toggleMicBtn = document.getElementById('toggle-mic-btn');
        const toggleCamBtn = document.getElementById('toggle-cam-btn');
        const micOnIcon = document.getElementById('mic-on-icon');
        const micOffIcon = document.getElementById('mic-off-icon');
        const camOnIcon = document.getElementById('cam-on-icon');
        const camOffIcon = document.getElementById('cam-off-icon');

        let localStream = null;
        let peerConnections = {};
        let isMicOn = false;
        let isCamOn = false;
        const STUN_SERVER = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

        async function startMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                // Start with media off
                localStream.getAudioTracks()[0].enabled = isMicOn;
                localStream.getVideoTracks()[0].enabled = isCamOn;
                updateMediaButtonsUI();
            } catch (error) {
                console.error("Error accessing media devices.", error);
                alert("Could not access camera and microphone. Please allow permissions and try again.");
            }
        }

        function updateMediaButtonsUI() {
            micOnIcon.classList.toggle('hidden', !isMicOn);
            micOffIcon.classList.toggle('hidden', isMicOn);
            toggleMicBtn.classList.toggle('bg-green-600', isMicOn);
            toggleMicBtn.classList.toggle('hover:bg-green-500', isMicOn);
            toggleMicBtn.classList.toggle('bg-red-600', !isMicOn);
            toggleMicBtn.classList.toggle('hover:bg-red-500', !isMicOn);

            camOnIcon.classList.toggle('hidden', !isCamOn);
            camOffIcon.classList.toggle('hidden', isCamOn);
            toggleCamBtn.classList.toggle('bg-green-600', isCamOn);
            toggleCamBtn.classList.toggle('hover:bg-green-500', isCamOn);
            toggleCamBtn.classList.toggle('bg-red-600', !isCamOn);
            toggleCamBtn.classList.toggle('hover:bg-red-500', !isCamOn);
        }

        toggleMicBtn.addEventListener('click', () => {
            isMicOn = !isMicOn;
            if (localStream) localStream.getAudioTracks()[0].enabled = isMicOn;
            updateMediaButtonsUI();
        });

        toggleCamBtn.addEventListener('click', () => {
            isCamOn = !isCamOn;
            if (localStream) localStream.getVideoTracks()[0].enabled = isCamOn;
            updateMediaButtonsUI();
        });


        // --- 5. PLAYER MOVEMENT & CONTROLS ---
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const playerSpeed = 3;
        const joystick = { active: false, x: 0, y: 0, dx: 0, dy: 0, radius: document.getElementById('joystick-container').offsetWidth / 2 };
        window.addEventListener('keydown', (e) => {
            if (document.activeElement !== chatInput && keys.hasOwnProperty(e.key)) {
                e.preventDefault(); // Prevent scrolling the page with arrow keys
                keys[e.key] = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        joystickContainer.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; });
        joystickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault(); if (!joystick.active) return; const touch = e.touches[0]; const rect = joystickContainer.getBoundingClientRect();
            joystick.x = touch.clientX - rect.left - joystick.radius; joystick.y = touch.clientY - rect.top - joystick.radius;
            const mag = Math.sqrt(joystick.x**2 + joystick.y**2);
            if (mag > joystick.radius) { joystick.x = (joystick.x / mag) * joystick.radius; joystick.y = (joystick.y / mag) * joystick.radius; }
            joystick.dx = joystick.x / joystick.radius; joystick.dy = joystick.y / joystick.radius;
            joystickThumb.style.transform = `translate(${joystick.x}px, ${joystick.y}px)`;
        });
        joystickContainer.addEventListener('touchend', (e) => { e.preventDefault(); joystick.active = false; joystick.dx = 0; joystick.dy = 0; joystickThumb.style.transform = `translate(0px, 0px)`; });

        function updateMyPlayerPosition() {
            if (!gameState.players[myPlayerId]) return;
            let dx = joystick.active ? joystick.dx : (keys.ArrowRight ? 1 : 0) - (keys.ArrowLeft ? 1 : 0);
            let dy = joystick.active ? joystick.dy : (keys.ArrowDown ? 1 : 0) - (keys.ArrowUp ? 1 : 0);
            const mag = Math.sqrt(dx**2 + dy**2);
            if (mag > 0) {
                gameState.players[myPlayerId].x += (dx / mag) * playerSpeed;
                gameState.players[myPlayerId].y += (dy / mag) * playerSpeed;
            }
            gameState.players[myPlayerId].x = Math.max(10, Math.min(canvas.width - 10, gameState.players[myPlayerId].x));
            gameState.players[myPlayerId].y = Math.max(10, Math.min(canvas.height - 10, gameState.players[myPlayerId].y));
        }

        // --- 6. GAME LOOP ---
        function draw() {
            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
            ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = '#374151';
            for (let i = 0; i < canvas.width; i += 40) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }
            for (let i = 0; i < canvas.height; i += 40) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke(); }
            for (const id in gameState.players) {
                const p = gameState.players[id]; ctx.fillStyle = id === myPlayerId ? 'cyan' : (p.isAlive ? 'red' : 'gray');
                ctx.fillRect(p.x - 10, p.y - 10, 20, 20); ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.fillText(p.name, p.x, p.y - 15);
            }
        }
        function gameLoop() {
            if (gameState.players[myPlayerId]?.isAlive) updateMyPlayerPosition();
            draw(); requestAnimationFrame(gameLoop);
        }

        // --- 7. REALTIME & WEBRTC SIGNALING ---
        async function createPeerConnection(targetId) {
            const pc = new RTCPeerConnection(STUN_SERVER);
            peerConnections[targetId] = pc;

            if (localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }

            pc.onicecandidate = event => {
                if (event.candidate) {
                    channel.send({ type: 'broadcast', event: 'webrtc-ice-candidate', payload: { to: targetId, from: myPlayerId, candidate: event.candidate } });
                }
            };

            pc.ontrack = event => {
                remoteVideoPlaceholder.style.display = 'none';
                let remoteVideo = document.getElementById(`video-${targetId}`);
                if (!remoteVideo) {
                    remoteVideo = document.createElement('video');
                    remoteVideo.id = `video-${targetId}`;
                    remoteVideo.autoplay = true;
                    remoteVideo.playsInline = true;
                    remoteVideosContainer.appendChild(remoteVideo);
                }
                remoteVideo.srcObject = event.streams[0];
            };
            return pc;
        }

        async function broadcastMyState() {
             if (!gameState.players[myPlayerId]) return;
             await channel.send({ type: 'broadcast', event: 'player-update', payload: { id: myPlayerId, data: gameState.players[myPlayerId] } });
        }

        channel
            .on('broadcast', { event: 'player-update' }, ({ payload }) => {
                 if (payload.id === myPlayerId) return;
                 const isNewPlayer = !gameState.players[payload.id];
                 gameState.players[payload.id] = payload.data;
                 if (isNewPlayer) { // New player joined, initiate WebRTC
                     console.log(`New player ${payload.data.name} detected. Creating offer.`);
                     createPeerConnection(payload.id).then(pc => {
                         pc.createOffer().then(offer => {
                             pc.setLocalDescription(offer);
                             channel.send({ type: 'broadcast', event: 'webrtc-offer', payload: { to: payload.id, from: myPlayerId, offer } });
                         });
                     });
                 }
            })
            .on('broadcast', { event: 'webrtc-offer' }, async ({ payload }) => {
                if (payload.to !== myPlayerId) return;
                console.log(`Received WebRTC offer from ${payload.from}`);
                const pc = await createPeerConnection(payload.from);
                await pc.setRemoteDescription(new RTCSessionDescription(payload.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                channel.send({ type: 'broadcast', event: 'webrtc-answer', payload: { to: payload.from, from: myPlayerId, answer } });
            })
            .on('broadcast', { event: 'webrtc-answer' }, async ({ payload }) => {
                if (payload.to !== myPlayerId) return;
                console.log(`Received WebRTC answer from ${payload.from}`);
                const pc = peerConnections[payload.from];
                if (pc) await pc.setRemoteDescription(new RTCSessionDescription(payload.answer));
            })
            .on('broadcast', { event: 'webrtc-ice-candidate' }, ({ payload }) => {
                if (payload.to !== myPlayerId) return;
                const pc = peerConnections[payload.from];
                if (pc && payload.candidate) {
                    pc.addIceCandidate(new RTCIceCandidate(payload.candidate));
                }
            })
            .on('broadcast', { event: 'player-leave' }, ({ payload }) => {
                 console.log(`Player ${gameState.players[payload.id]?.name} left.`);
                 delete gameState.players[payload.id];
                 if (peerConnections[payload.id]) {
                     peerConnections[payload.id].close();
                     delete peerConnections[payload.id];
                 }
                 const remoteVideo = document.getElementById(`video-${payload.id}`);
                 if (remoteVideo) remoteVideo.remove();
                 if (Object.keys(peerConnections).length === 0) {
                     remoteVideoPlaceholder.style.display = 'block';
                 }
            })
            .subscribe((status) => {
                if (status === 'SUBSCRIBED') {
                    loadingScreen.classList.add('hidden');
                    lobbyScreen.classList.remove('hidden');
                }
            });
            
        // --- 8. INITIALIZATION ---
        function init() {
            joinGameBtn.onclick = async () => {
                const username = usernameInput.value.trim();
                if (username.length < 3) { alert('Please enter a name (at least 3 characters).'); return; }

                await startMedia(); // Get media access before joining

                gameState.players[myPlayerId] = { name: username, x: Math.random() * 500 + 50, y: Math.random() * 300 + 50, isAlive: true };
                lobbyScreen.classList.add('hidden');
                gameLoop();
                setInterval(broadcastMyState, 1000 / 30);
            };
            
            window.addEventListener('beforeunload', async () => {
                await channel.send({ type: 'broadcast', event: 'player-leave', payload: { id: myPlayerId } });
                supabase.removeChannel(channel);
            });
        }

        init();
    </script>
</body>
</html>




