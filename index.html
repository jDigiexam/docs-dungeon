<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>8-Bit Office Mystery</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        body { font-family: 'Courier New', Courier, monospace; }
        #game-canvas { image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        /* Simple focus styles for accessibility and clarity */
        input:focus, button:focus { outline: 2px solid #4f46e5; outline-offset: 2px; }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen flex flex-col md:flex-row items-stretch">

    <!-- UI Panel (Left Side on Desktop, Bottom on Mobile) -->
    <div id="ui-panel" class="w-full md:w-72 lg:w-96 bg-gray-800 p-4 flex flex-col space-y-2 overflow-y-auto order-last md:order-first h-1/3 md:h-full">
        <!-- Status & Clues -->
        <div class="bg-gray-900/50 p-2 rounded">
            <div id="status-text" class="text-lg">Status: Alive</div>
            <div id="clues-text" class="text-lg">Clues Found: 0/5</div>
        </div>
        
        <!-- Video Streams -->
        <div class="flex space-x-2">
            <div class="w-1/2 relative aspect-square">
                <video id="local-video" autoplay muted playsinline class="w-full h-full object-cover bg-gray-700 rounded-md border-2 border-gray-500"></video>
                <div id="local-video-overlay" class="absolute inset-0 flex items-center justify-center bg-black/50 text-xs font-bold">YOU</div>
            </div>
            <div id="remote-videos-container" class="w-1/2 bg-gray-700 rounded-md flex items-center justify-center text-sm relative overflow-hidden aspect-square">
                <span id="remote-video-placeholder">Teammate</span>
            </div>
        </div>

         <!-- Video Controls -->
        <div class="flex justify-center space-x-4">
            <button id="toggle-mic-btn" class="p-3 bg-red-600 rounded-full hover:bg-red-500 text-white transition-colors">
                <svg id="mic-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                </svg>
                <svg id="mic-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M5 5l14 14" />
                </svg>
            </button>
            <button id="toggle-cam-btn" class="p-3 bg-red-600 rounded-full hover:bg-red-500 text-white transition-colors">
                <svg id="cam-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                     <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                </svg>
                <svg id="cam-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                   <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                   <path stroke-linecap="round" stroke-linejoin="round" d="M5 5l14 14" />
                </svg>
            </button>
        </div>

        <!-- Chat Box -->
        <div class="flex flex-col flex-grow min-h-0">
             <div id="chat-box" class="flex-grow bg-black/60 rounded-md p-2 overflow-y-auto text-sm mb-2">
                <div id="chat-messages"></div>
            </div>
            <input id="chat-input" type="text" placeholder="Type a message..." class="w-full bg-gray-700 border-2 border-gray-500 rounded-md p-2 text-sm">
        </div>
    </div>

    <!-- Main Game Container -->
    <div id="game-container" class="relative flex-grow bg-black shadow-lg rounded-lg overflow-hidden">
        
        <!-- Loading Screen -->
        <div id="loading-screen" class="absolute inset-0 bg-gray-900 flex items-center justify-center z-30">
            <div class="text-center">
                <h1 class="text-4xl font-bold mb-4">8-Bit Office Mystery</h1>
                <p>Loading...</p>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobby-screen" class="absolute inset-0 bg-gray-800 flex items-center justify-center z-20 hidden">
            <div class="text-center p-8 bg-gray-700 rounded-lg shadow-xl">
                <h2 class="text-2xl mb-4">Enter the Game</h2>
                <input id="username-input" type="text" placeholder="Enter your name" class="text-black p-2 rounded w-full mb-4">
                <button id="join-game-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded w-full">Join Game</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="relative w-full h-full">
            <canvas id="game-canvas" class="w-full h-full"></canvas>

            <!-- Virtual Joystick for Mobile -->
            <div id="joystick-container" class="absolute bottom-10 right-10 w-32 h-32 rounded-full bg-gray-500/30 flex items-center justify-center select-none md:hidden">
                <div id="joystick-thumb" class="w-16 h-16 rounded-full bg-gray-400/50"></div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- 0. SUPABASE & GENERAL SETUP ---
        const SUPABASE_URL = 'https://uypjowqnnostwxmcflnm.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV5cGpvd3Fubm9zdHd4bWNmbG5tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAwMTg3NjksImV4cCI6MjA3NTU5NDc2OX0.iUDDwG-TXg5AZNdXxKViz9JomSGtUgiwGnKcs7GBnaU';
        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loading-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const joinGameBtn = document.getElementById('join-game-btn');
        const usernameInput = document.getElementById('username-input');
        const chatInput = document.getElementById('chat-input');
        const cluesText = document.getElementById('clues-text');

        const gameState = {
            players: {},
            maze: [],
            clues: []
        };
        let myPlayerId = null;
        let gameChannel = null;
        
        // Maze and Clue Constants
        const MAZE_WIDTH = 25; // In cells
        const MAZE_HEIGHT = 20; // In cells
        const NUM_CLUES = 5;
        const MIN_CLUE_DISTANCE = 5; // Min grid cells between clues

        let CELL_SIZE = 32; // This will be calculated dynamically

        // --- 1. INITIALIZATION ---
        window.onload = () => {
            initGame();
        };

        window.onresize = () => {
             resizeCanvas();
        };

        function initGame() {
            resizeCanvas();
            loadingScreen.style.display = 'none';
            lobbyScreen.style.display = 'flex';
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            CELL_SIZE = Math.min(canvas.width / MAZE_WIDTH, canvas.height / MAZE_HEIGHT);
            drawGame(); 
        }

        joinGameBtn.addEventListener('click', () => {
            const username = usernameInput.value.trim() || `Player_${Math.floor(Math.random() * 1000)}`;
            myPlayerId = `player_${Date.now()}`;
            joinGame(username);
        });


        // --- 2. GAME LOGIC ---

        function joinGame(username) {
            lobbyScreen.style.display = 'none';
            
            // Generate maze and clues (only the first player should do this in a real game)
            // For now, everyone generates their own, but they'll sync up via broadcast.
            gameState.maze = generateMaze(MAZE_WIDTH, MAZE_HEIGHT);
            gameState.clues = placeClues(gameState.maze, NUM_CLUES, MIN_CLUE_DISTANCE);

            const startPos = { x: CELL_SIZE * 1.5, y: CELL_SIZE * 1.5 };
            gameState.players[myPlayerId] = {
                id: myPlayerId,
                username: username,
                x: startPos.x,
                y: startPos.y,
                color: `hsl(${Math.random() * 360}, 80%, 70%)`
            };

            setupSupabaseChannels();
            gameLoop();
        }

        function gameLoop() {
            updateMyPlayerPosition();
            checkClueCollection();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // --- 3. DRAWING & RENDERING ---
        
        function drawGame() {
            if (!ctx) return;
            // Clear canvas with black background
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Maze
            drawMaze();
            
            // Draw Clues
            drawClues();

            // Draw Players
            Object.values(gameState.players).forEach(player => {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x - 5, player.y - 5, 10, 10);
            });
        }
        
        function drawMaze() {
            ctx.strokeStyle = '#374151'; // gray-700
            ctx.lineWidth = 2;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const cell = gameState.maze[y][x];
                    const xPos = x * CELL_SIZE;
                    const yPos = y * CELL_SIZE;
                    if (cell.walls.top) {
                        ctx.beginPath();
                        ctx.moveTo(xPos, yPos);
                        ctx.lineTo(xPos + CELL_SIZE, yPos);
                        ctx.stroke();
                    }
                    if (cell.walls.right) {
                        ctx.beginPath();
                        ctx.moveTo(xPos + CELL_SIZE, yPos);
                        ctx.lineTo(xPos + CELL_SIZE, yPos + CELL_SIZE);
                        ctx.stroke();
                    }
                     if (cell.walls.bottom) {
                        ctx.beginPath();
                        ctx.moveTo(xPos + CELL_SIZE, yPos + CELL_SIZE);
                        ctx.lineTo(xPos, yPos + CELL_SIZE);
                        ctx.stroke();
                    }
                    if (cell.walls.left) {
                        ctx.beginPath();
                        ctx.moveTo(xPos, yPos + CELL_SIZE);
                        ctx.lineTo(xPos, yPos);
                        ctx.stroke();
                    }
                }
            }
        }

        function drawClues() {
            ctx.fillStyle = 'yellow';
            gameState.clues.forEach(clue => {
                if (!clue.collected) {
                    const xPos = (clue.x + 0.5) * CELL_SIZE;
                    const yPos = (clue.y + 0.5) * CELL_SIZE;
                    ctx.beginPath();
                    ctx.arc(xPos, yPos, CELL_SIZE * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }


        // --- 4. SUPABASE REALTIME ---

        function setupSupabaseChannels() {
             const channelName = 'game-channel-main';
             gameChannel = supabaseClient.channel(channelName, {
                config: {
                    broadcast: { self: false }
                }
            });

            gameChannel
                .on('broadcast', { event: 'player_update' }, ({ payload }) => {
                     // In a real game, you might need to handle the initial maze/clue state here
                    if (payload.id && payload.id !== myPlayerId) {
                        gameState.players[payload.id] = payload;
                    }
                })
                .on('broadcast', { event: 'clue_update' }, ({ payload }) => {
                    const clue = gameState.clues.find(c => c.id === payload.clueId);
                    if(clue) clue.collected = true;
                    updateClueCounter();
                })
                .on('presence', { event: 'sync' }, () => {
                    const presenceState = gameChannel.presenceState();
                })
                .on('presence', { event: 'leave' }, ({ leftPresences }) => {
                    leftPresences.forEach(p => {
                        delete gameState.players[p.player_id];
                    });
                })
                .subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        await gameChannel.track({ player_id: myPlayerId, username: gameState.players[myPlayerId].username });
                        // Broadcast initial state
                        broadcastPlayerState();
                    }
                });
        }
        
        function broadcastPlayerState() {
             if (gameChannel && gameState.players[myPlayerId]) {
                gameChannel.send({
                    type: 'broadcast',
                    event: 'player_update',
                    payload: gameState.players[myPlayerId]
                });
            }
        }
        
        function broadcastClueCollected(clueId) {
             if (gameChannel) {
                gameChannel.send({
                    type: 'broadcast',
                    event: 'clue_update',
                    payload: { clueId: clueId }
                });
            }
        }


        // --- 5. PLAYER MOVEMENT & CONTROLS ---
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const playerSpeed = 2; // Adjusted for maze navigation
        const joystick = { active: false, x: 0, y: 0, dx: 0, dy: 0, radius: document.getElementById('joystick-container').offsetWidth / 2 };
        
        window.addEventListener('keydown', (e) => {
            if (document.activeElement !== chatInput && keys.hasOwnProperty(e.key)) {
                e.preventDefault();
                keys[e.key] = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        joystickContainer.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; });
        joystickContainer.addEventListener('touchmove', (e) => {
            if (!joystick.active) return;
            e.preventDefault();
            const rect = joystickContainer.getBoundingClientRect();
            joystick.x = e.touches[0].clientX - rect.left - joystick.radius;
            joystick.y = e.touches[0].clientY - rect.top - joystick.radius;
            const mag = Math.sqrt(joystick.x**2 + joystick.y**2);
            if (mag > joystick.radius) {
                joystick.x = (joystick.x / mag) * joystick.radius;
                joystick.y = (joystick.y / mag) * joystick.radius;
            }
            joystickThumb.style.transform = `translate(${joystick.x}px, ${joystick.y}px)`;
            joystick.dx = joystick.x / joystick.radius;
            joystick.dy = joystick.y / joystick.radius;
        });
        joystickContainer.addEventListener('touchend', (e) => { e.preventDefault(); joystick.active = false; joystick.dx = 0; joystick.dy = 0; joystickThumb.style.transform = `translate(0px, 0px)`; });

        function updateMyPlayerPosition() {
            const player = gameState.players[myPlayerId];
            if (!player) return;

            let dx = joystick.active ? joystick.dx : (keys.ArrowRight ? 1 : 0) - (keys.ArrowLeft ? 1 : 0);
            let dy = joystick.active ? joystick.dy : (keys.ArrowDown ? 1 : 0) - (keys.ArrowUp ? 1 : 0);
            const mag = Math.sqrt(dx**2 + dy**2);
            
            if (mag > 0) {
                const normalizedDx = (dx / mag) * playerSpeed;
                const normalizedDy = (dy / mag) * playerSpeed;
                
                let nextX = player.x + normalizedDx;
                let nextY = player.y + normalizedDy;
                
                // --- Collision Detection ---
                const playerRadius = 4; // A small buffer
                let currentCellX = Math.floor(player.x / CELL_SIZE);
                let currentCellY = Math.floor(player.y / CELL_SIZE);
                let nextCellX = Math.floor(nextX / CELL_SIZE);
                let nextCellY = Math.floor(nextY / CELL_SIZE);

                if (normalizedDx > 0 && gameState.maze[currentCellY][currentCellX].walls.right && nextX + playerRadius > (currentCellX + 1) * CELL_SIZE) {
                    nextX = (currentCellX + 1) * CELL_SIZE - playerRadius;
                }
                if (normalizedDx < 0 && gameState.maze[currentCellY][currentCellX].walls.left && nextX - playerRadius < currentCellX * CELL_SIZE) {
                    nextX = currentCellX * CELL_SIZE + playerRadius;
                }
                if (normalizedDy > 0 && gameState.maze[currentCellY][currentCellX].walls.bottom && nextY + playerRadius > (currentCellY + 1) * CELL_SIZE) {
                    nextY = (currentCellY + 1) * CELL_SIZE - playerRadius;
                }
                if (normalizedDy < 0 && gameState.maze[currentCellY][currentCellX].walls.top && nextY - playerRadius < currentCellY * CELL_SIZE) {
                    nextY = currentCellY * CELL_SIZE + playerRadius;
                }
                
                player.x = nextX;
                player.y = nextY;

                broadcastPlayerState();
            }
        }
        
        // --- 6. MAZE & CLUE GENERATION/LOGIC ---

        function generateMaze(width, height) {
            let maze = Array.from({ length: height }, (_, y) => 
                Array.from({ length: width }, (_, x) => ({
                    x, y,
                    walls: { top: true, right: true, bottom: true, left: true },
                    visited: false
                }))
            );

            let stack = [];
            let current = maze[0][0];
            current.visited = true;
            let visitedCount = 1;

            const getNeighbors = (cell) => {
                let neighbors = [];
                const {x, y} = cell;
                if (y > 0 && !maze[y - 1][x].visited) neighbors.push(maze[y - 1][x]); // Top
                if (x < width - 1 && !maze[y][x + 1].visited) neighbors.push(maze[y][x + 1]); // Right
                if (y < height - 1 && !maze[y + 1][x].visited) neighbors.push(maze[y + 1][x]); // Bottom
                if (x > 0 && !maze[y][x - 1].visited) neighbors.push(maze[y][x - 1]); // Left
                return neighbors;
            };

            while (visitedCount < width * height) {
                let neighbors = getNeighbors(current);
                if (neighbors.length > 0) {
                    stack.push(current);
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    // Remove walls between current and next
                    if (next.y < current.y) { // Top
                        current.walls.top = false;
                        next.walls.bottom = false;
                    } else if (next.x > current.x) { // Right
                        current.walls.right = false;
                        next.walls.left = false;
                    } else if (next.y > current.y) { // Bottom
                        current.walls.bottom = false;
                        next.walls.top = false;
                    } else if (next.x < current.x) { // Left
                        current.walls.left = false;
                        next.walls.right = false;
                    }
                    current = next;
                    current.visited = true;
                    visitedCount++;
                } else if (stack.length > 0) {
                    current = stack.pop();
                }
            }
            return maze;
        }
        
        function placeClues(maze, numClues, minDistance) {
            let clues = [];
            let possibleLocations = [];
            // Get all possible floor locations
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[0].length; x++) {
                    possibleLocations.push({x, y});
                }
            }
            
            // Shuffle locations to randomize
            for (let i = possibleLocations.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [possibleLocations[i], possibleLocations[j]] = [possibleLocations[j], possibleLocations[i]];
            }

            while (clues.length < numClues && possibleLocations.length > 0) {
                let loc = possibleLocations.pop();
                let tooClose = clues.some(clue => Math.sqrt((clue.x - loc.x)**2 + (clue.y - loc.y)**2) < minDistance);

                if (!tooClose) {
                    clues.push({
                        id: `clue_${clues.length}`,
                        x: loc.x,
                        y: loc.y,
                        collected: false
                    });
                }
            }
            return clues;
        }
        
        function checkClueCollection() {
            const player = gameState.players[myPlayerId];
            if(!player) return;
            
            const playerCellX = Math.floor(player.x / CELL_SIZE);
            const playerCellY = Math.floor(player.y / CELL_SIZE);

            gameState.clues.forEach(clue => {
                if (!clue.collected && clue.x === playerCellX && clue.y === playerCellY) {
                    clue.collected = true;
                    console.log(`Collected clue ${clue.id}`);
                    broadcastClueCollected(clue.id);
                    updateClueCounter();
                }
            });
        }
        
        function updateClueCounter() {
            const collectedCount = gameState.clues.filter(c => c.collected).length;
            cluesText.textContent = `Clues Found: ${collectedCount}/${NUM_CLUES}`;
        }
        
        // --- 7. WEBRTC (VIDEO/AUDIO CHAT) ---
        // Placeholder for WebRTC implementation
        
    </script>
</body>
</html>

