<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="icon" href="data:,">
    <title>8-Bit Dungeon Mystery</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        body { font-family: 'Courier New', Courier, monospace; }
        #game-canvas, #lobby-preview-canvas, .char-option { image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        input:focus, button:focus, select:focus { outline: 2px solid #4f46e5; outline-offset: 2px; }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen flex flex-col md:flex-row items-stretch">

    <audio id="lobby-music" loop src="assets/dungeon lobby.mp3"></audio>
    <audio id="dungeon-music" loop src="assets/the mysterious dungeon.mp3"></audio>

    <div id="ui-panel" class="w-full md:w-72 lg:w-96 bg-gray-800 p-2 md:p-4 flex flex-col space-y-2 order-last md:order-first h-48 md:h-full overflow-y-auto">
        <div id="game-status-panel" class="bg-gray-900/50 p-2 rounded hidden">
            <div id="status-text" class="text-lg">Status: Alive</div>
            <div id="clues-text" class="text-lg">Chests Found: 0/7</div>
        </div>
        
        <div class="flex flex-row md:flex-col space-x-2 md:space-x-0 md:space-y-2 flex-grow min-h-0">
            <div class="flex flex-col space-y-2 w-1/2 md:w-full">
                <div id="video-streams-container" class="grid grid-cols-2 gap-1 flex-grow">
                </div>
                <div class="flex justify-center space-x-2 md:space-x-4">
                    <button id="toggle-mic-btn" class="p-2 md:p-3 bg-red-600 rounded-full hover:bg-red-500 text-white transition-colors">
                        <svg id="mic-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 md:h-6 md:w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>
                        <svg id="mic-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 md:h-6 md:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /><path stroke-linecap="round" stroke-linejoin="round" d="M5 5l14 14" /></svg>
                    </button>
                    <button id="toggle-cam-btn" class="p-2 md:p-3 bg-red-600 rounded-full hover:bg-red-500 text-white transition-colors">
                        <svg id="cam-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 md:h-6 md:w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" /></svg>
                        <svg id="cam-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 md:h-6 md:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" /><path stroke-linecap="round" stroke-linejoin="round" d="M5 5l14 14" /></svg>
                    </button>
                </div>
            </div>
            
            <div class="flex flex-col flex-grow min-h-0 w-1/2 md:w-full">
                 <div id="chat-box" class="flex-grow bg-black/60 rounded-md p-2 overflow-y-auto text-sm mb-2">
                      <div id="chat-messages"></div>
                 </div>
                <input id="chat-input" type="text" placeholder="Type a message..." class="w-full bg-gray-700 border-2 border-gray-500 rounded-md p-2 text-sm">
            </div>
        </div>
    </div>

    <div id="game-container" class="relative flex-grow bg-black shadow-lg rounded-lg overflow-hidden">
        
        <div id="loading-screen" class="absolute inset-0 bg-gray-900 flex items-center justify-center z-50">
            <div class="text-center">
                <h1 class="text-4xl font-bold mb-4">Dungeon Mystery</h1>
                <p>Loading Assets...</p>
            </div>
        </div>

        <div id="char-creation-screen" class="absolute inset-0 bg-gray-800 flex items-center justify-center z-40 hidden">
             <div class="text-center p-8 bg-gray-700 rounded-lg shadow-xl w-11/12 max-w-md">
                <h2 class="text-2xl mb-4">Character Customization</h2>
                <canvas id="lobby-preview-canvas" width="128" height="128" class="bg-gray-800 mx-auto mb-4 rounded-lg border-2 border-gray-600"></canvas>
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">Choose your Hero:</label>
                    <div id="character-grid" class="grid grid-cols-5 sm:grid-cols-6 gap-2 bg-gray-900/50 p-2 rounded-lg max-h-48 overflow-y-auto"></div>
                </div>
                <input id="username-input" type="text" placeholder="Enter your name" class="text-black p-2 rounded w-full mb-4">
                <button id="join-game-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded w-full">Join Game</button>
            </div>
        </div>

        <div id="ready-room-screen" class="absolute inset-0 bg-gray-800 flex flex-col items-center justify-center z-30 hidden p-8">
            <h2 class="text-3xl mb-6">Game Lobby</h2>
            <div id="player-list" class="w-full max-w-lg bg-gray-700 rounded-lg p-4 mb-6 space-y-2"></div>
            <div class="flex space-x-4">
                <button id="ready-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-6 rounded text-xl">Ready Up</button>
                <button id="start-game-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded text-xl hidden disabled:opacity-50" disabled>Start Game</button>
            </div>
        </div>
        
        <div id="game-over-screen" class="absolute inset-0 bg-black/70 flex flex-col items-center justify-center z-20 hidden">
            <h2 id="game-over-text" class="text-5xl font-bold text-white mb-4">Game Over</h2>
            <p id="game-over-subtext" class="text-xl text-gray-300"></p>
            <button id="play-again-btn" class="mt-6 bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded text-xl hidden">Play Again?</button>
            <p id="waiting-for-host-text" class="mt-6 text-lg text-gray-400 hidden">Waiting for the host to start a new game...</p>
        </div>

        <div id="game-screen" class="relative w-full h-full hidden">
            <canvas id="game-canvas" class="w-full h-full"></canvas>
            <canvas id="minimap-canvas" class="absolute top-20 sm:top-4 right-4 border-2 border-gray-500 bg-black/50" width="150" height="120"></canvas>
            <div id="joystick-container" class="absolute bottom-10 right-10 w-32 h-32 rounded-full bg-gray-500/30 flex items-center justify-center select-none md:hidden">
                <div id="joystick-thumb" class="w-16 h-16 rounded-full bg-gray-400/50"></div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- 0. SUPABASE & GENERAL SETUP ---
        const SUPABASE_URL = 'https://uypjowqnnostwxmcflnm.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV5cGpvd3Fubm9zdHd4bWNmbG5tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAwMTg3NjksImV4cCI6MjA3NTU5NDc2OX0.iUDDwG-TXg5AZNdXxKViz9JomSGtUgiwGnKcs7GBnaU';
        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

        // DOM Elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const loadingScreen = document.getElementById('loading-screen');
        const charCreationScreen = document.getElementById('char-creation-screen');
        const readyRoomScreen = document.getElementById('ready-room-screen');
        const gameScreen = document.getElementById('game-screen');
        const uiPanel = document.getElementById('ui-panel');
        const gameStatusPanel = document.getElementById('game-status-panel');
        const joinGameBtn = document.getElementById('join-game-btn');
        const readyBtn = document.getElementById('ready-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const playerList = document.getElementById('player-list');
        const usernameInput = document.getElementById('username-input');
        const chatInput = document.getElementById('chat-input');
        const chatBox = document.getElementById('chat-box');
        const chatMessages = document.getElementById('chat-messages');
        const cluesText = document.getElementById('clues-text');
        const statusText = document.getElementById('status-text');
        const videoStreamsContainer = document.getElementById('video-streams-container');
        const toggleMicBtn = document.getElementById('toggle-mic-btn');
        const toggleCamBtn = document.getElementById('toggle-cam-btn');
        const micOnIcon = document.getElementById('mic-on-icon');
        const micOffIcon = document.getElementById('mic-off-icon');
        const camOnIcon = document.getElementById('cam-on-icon');
        const camOffIcon = document.getElementById('cam-off-icon');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverText = document.getElementById('game-over-text');
        const gameOverSubtext = document.getElementById('game-over-subtext');
        const lobbyPreviewCanvas = document.getElementById('lobby-preview-canvas');
        const characterGrid = document.getElementById('character-grid');
        const playAgainBtn = document.getElementById('play-again-btn');
        const waitingForHostText = document.getElementById('waiting-for-host-text');

        // Game State
        const gameState = { players: {}, levels: {}, clues: [], npcs: [], gamePhase: 'loading' };
        let myPlayerId = null;
        let gameChannel = null;
        let selectedSpriteKey = 'red_wizard';
        let lastTime = 0;
        
        // Game Constants
        const TILE_SIZE = 128;
        const SPRITE_SIZE = 128;
        const MAP_WIDTH = 60; 
        const MAP_HEIGHT = 50;
        const NUM_CLUES = 7;
        const MIN_CLUE_DISTANCE = 5;
        const PLAYER_SPEED = 600; 
        const MONSTER_SPEED = 660; 
        const SIGHT_RADIUS = 6;
        const CAMERA_ZOOM = 0.5;
        const DEATH_TIMER_DURATION = 30000;
        const MIN_SPAWN_DISTANCE = 15 * TILE_SIZE;

        // WebRTC State
        let localStream;
        let peerConnections = {};
        const peerConnectionConfig = { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] };
        let isMicOn = false;
        let isCamOn = false;

        // Asset Loading
        const assets = { tiles: new Image(), chars: new Image(), items: new Image(), monsters: new Image(), scenery: new Image(), giants: new Image() };
        let assetsLoadedCount = 0;
        
        const tileMap = {
            FLOOR_VARS: [[0, 2], [1, 2], [2, 2], [3, 2], [4, 2]],
            WALL_V: [12, 5], WALL_H: [13, 4], WALL_TL: [12, 4], WALL_TR: [14, 4], WALL_BL: [12, 6], WALL_BR: [14, 6], WALL_T: [13, 6],
            WALL_B: [13, 5], WALL_L: [14, 5], WALL_R: [12, 5], WALL_CROSS: [13,5], STAIRS: [4, 1],
        };

        const sprites = {
            red_wizard: {sx:0,sy:0,name:"Red Wizard"}, orange_wizard: {sx:128,sy:0,name:"Orange Wizard"}, blue_wizard: {sx:256,sy:0,name:"Blue Wizard"}, green_wizard: {sx:384,sy:0,name:"Green Wizard"},
            dark_wizard: {sx:0,sy:128,name:"Dark Wizard"}, pink_wizard: {sx:128,sy:128,name:"Pink Wizard"}, grey_wizard: {sx:256,sy:128,name:"Grey Wizard"}, fire_wizard: {sx:384,sy:128,name:"Fire Wizard"},
            lime_wizard: {sx:0,sy:256,name:"Lime Wizard"}, sky_wizard: {sx:128,sy:256,name:"Sky Wizard"}, white_wizard: {sx:256,sy:256,name:"White Wizard"}, yellow_wizard: {sx:384,sy:256,name:"Yellow Wizard"},
            brown_wizard: {sx:0,sy:384,name:"Brown Wizard"}, dark_knight: {sx:128,sy:384,name:"Dark Knight"}, silver_knight: {sx:256,sy:384,name:"Silver Knight"}, horned_knight: {sx:384,sy:384,name:"Horned Knight"},
            white_knight: {sx:0,sy:512,name:"White Knight"}, villager: {sx:128,sy:512,name:"Villager"}, ranger: {sx:256,sy:512,name:"Ranger"},
        };
        
        const giantSprites = [
            {sx: 0,   sy: 0, sWidth: 256, sHeight: 256, sheet: 'giants'}, {sx: 256, sy: 0, sWidth: 256, sHeight: 256, sheet: 'giants'}, {sx: 512, sy: 0, sWidth: 256, sHeight: 256, sheet: 'giants'},
            {sx: 0,   sy: 256, sWidth: 256, sHeight: 256, sheet: 'giants'}, {sx: 256, sy: 256, sWidth: 256, sHeight: 256, sheet: 'giants'}, {sx: 512, sy: 256, sWidth: 256, sHeight: 256, sheet: 'giants'},
        ];

        const npcMonsterSprites = [
            {sx: 0,   sy: 0, sheet: 'monsters'}, {sx: 128, sy: 0, sheet: 'monsters'}, {sx: 256, sy: 0, sheet: 'monsters'},
            {sx: 384, sy: 0, sheet: 'monsters'}, {sx: 0,   sy: 128, sheet: 'monsters'}, {sx: 128, sy: 128, sheet: 'monsters'},
        ];

        const scenerySprites = [ {sx: 0, sy: 128}, {sx: 256, sy: 128}, {sx: 512, sy: 128}, {sx: 0, sy: 256}, {sx: 128, sy: 256} ];
        const tombstoneSprite = {sx: 128, sy: 768};
        const clueSprite = {sx: 128, sy: 0};
        const weaponSprite = {sx: 384, sy: 128}; 

        // --- 1. INITIALIZATION ---
        window.onload = () => initGame();
        window.onresize = () => resizeCanvas();

        function initGame() {
            const assetSources = {
                tiles: 'assets/Tiles8x.png', chars: 'assets/Chars8x.png', items: 'assets/Items8x.png',
                monsters: 'assets/Monsters8x.png', scenery: 'assets/Scenery8x.png', giants: 'assets/Giants8x.png'
            };
            const assetKeys = Object.keys(assetSources);
            let assetsToLoad = assetKeys.length;
            function assetLoaded() {
                assetsLoadedCount++;
                if (assetsLoadedCount === assetsToLoad) {
                    loadingScreen.style.display = 'none';
                    charCreationScreen.style.display = 'flex';
                    setupLobby();
                }
            }
            for (const key of assetKeys) {
                assets[key].src = assetSources[key];
                assets[key].onload = assetLoaded;
                assets[key].onerror = () => console.error(`Failed to load asset: ${assetSources[key]}`);
            }
            resizeCanvas();
        }

        function setupLobby() {
            characterGrid.innerHTML = ''; 
            for (const key in sprites) {
                const sprite = sprites[key];
                const charCanvas = document.createElement('canvas');
                charCanvas.width = 64; charCanvas.height = 64;
                charCanvas.className = 'char-option cursor-pointer rounded-md border-2 border-transparent hover:border-indigo-400 p-1';
                charCanvas.dataset.spriteKey = key;
                const charCtx = charCanvas.getContext('2d');
                charCtx.drawImage(assets.chars, sprite.sx, sprite.sy, SPRITE_SIZE, SPRITE_SIZE, 0, 0, 64, 64);
                characterGrid.appendChild(charCanvas);
                charCanvas.addEventListener('click', () => {
                    selectedSpriteKey = key;
                    drawLobbyPreview();
                });
            }
            usernameInput.addEventListener('input', () => { usernameInput.style.borderColor = ''; });
            drawLobbyPreview();
        }

        function drawLobbyPreview() {
            const previewCtx = lobbyPreviewCanvas.getContext('2d');
            const spriteInfo = sprites[selectedSpriteKey];
            previewCtx.clearRect(0, 0, lobbyPreviewCanvas.width, lobbyPreviewCanvas.height);
            if (spriteInfo && assets.chars.complete) {
                previewCtx.drawImage(assets.chars, spriteInfo.sx, spriteInfo.sy, SPRITE_SIZE, SPRITE_SIZE, 0, 0, lobbyPreviewCanvas.width, lobbyPreviewCanvas.height);
            }
            document.querySelectorAll('.char-option').forEach(canvas => {
                canvas.classList.toggle('border-indigo-400', canvas.dataset.spriteKey === selectedSpriteKey);
                canvas.classList.toggle('bg-indigo-900/50', canvas.dataset.spriteKey === selectedSpriteKey);
                canvas.classList.toggle('border-transparent', canvas.dataset.spriteKey !== selectedSpriteKey);
            });
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            if (!container) return;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if(assetsLoadedCount > 0 && gameState.gamePhase === 'playing') drawGame(); 
        }

        joinGameBtn.addEventListener('click', () => {
            const lobbyMusic = document.getElementById('lobby-music');
            const dungeonMusic = document.getElementById('dungeon-music');
            
            lobbyMusic.play().catch(e => {});
            dungeonMusic.play().catch(e => {});

            setTimeout(() => {
                dungeonMusic.pause();
                dungeonMusic.currentTime = 0;
                lobbyMusic.volume = 0.3; 
                if (lobbyMusic.paused) {
                    lobbyMusic.play().catch(e => console.error("Lobby music failed to play:", e));
                }
            }, 50);

            const username = usernameInput.value.trim();
            if (!username) { usernameInput.style.borderColor = 'red'; return; }
            myPlayerId = `player_${Date.now()}`;
            joinLobby(username);
        });

        readyBtn.addEventListener('click', () => {
            const me = gameState.players[myPlayerId];
            if (me) {
                me.isReady = !me.isReady;
                readyBtn.textContent = me.isReady ? 'Unready' : 'Ready Up';
                readyBtn.classList.toggle('bg-yellow-500', me.isReady);
                readyBtn.classList.toggle('hover:bg-yellow-400', me.isReady);
                readyBtn.classList.toggle('bg-green-600', !me.isReady);
                readyBtn.classList.toggle('hover:bg-green-500', !me.isReady);
                broadcastPlayerState();
                checkHostAndReadyStatus();
            }
        });

        startGameBtn.addEventListener('click', () => {
            if (!gameChannel || !gameState.players[myPlayerId]?.isHost) return;
            const playerIds = Object.values(gameState.players).map(p => p.id);
            playerIds.sort(() => Math.random() - 0.5);
            const monsterId = playerIds.length > 0 ? playerIds[0] : null;
            const monsterSpriteIndex = Math.floor(Math.random() * giantSprites.length);
            const levels = generateLevels();
            const clues = placeClues(levels, NUM_CLUES, MIN_CLUE_DISTANCE, gameState.players[myPlayerId]);
            const levelNames = Object.keys(levels);
            const hunters = Object.values(gameState.players).filter(p => p.id !== monsterId);
            const monster = gameState.players[monsterId];
            const npcs = spawnNpcs(levels, 10);

            hunters.forEach(hunter => {
                const randomLevelName = levelNames[Math.floor(Math.random() * levelNames.length)];
                const randomLevel = levels[randomLevelName];
                const startRoom = randomLevel.rooms[Math.floor(Math.random() * randomLevel.rooms.length)];
                hunter.level = randomLevelName;
                hunter.x = (startRoom.x + Math.floor(startRoom.w / 2)) * TILE_SIZE;
                hunter.y = (startRoom.y + Math.floor(startRoom.h / 2)) * TILE_SIZE;
                hunter.status = 'alive'; hunter.direction = 'right'; hunter.isMonster = false;
            });

            if (monster) {
                let monsterSpawnFound = false;
                for (let i = 0; i < 50; i++) {
                    const randomLevelName = levelNames[Math.floor(Math.random() * levelNames.length)];
                    const randomLevel = levels[randomLevelName];
                    const startRoom = randomLevel.rooms[Math.floor(Math.random() * randomLevel.rooms.length)];
                    const monsterX = (startRoom.x + Math.floor(startRoom.w / 2)) * TILE_SIZE;
                    const monsterY = (startRoom.y + Math.floor(startRoom.h / 2)) * TILE_SIZE;
                    const isSafe = hunters.every(h => {
                        if (h.level !== randomLevelName) return true;
                        const distance = Math.sqrt((h.x - monsterX)**2 + (h.y - monsterY)**2);
                        return distance > MIN_SPAWN_DISTANCE;
                    });
                    if (isSafe) {
                        monster.level = randomLevelName; monster.x = monsterX; monster.y = monsterY;
                        monsterSpawnFound = true;
                        break;
                    }
                }
                if (!monsterSpawnFound) {
                    const randomLevelName = levelNames[Math.floor(Math.random() * levelNames.length)];
                    const randomLevel = levels[randomLevelName];
                    const startRoom = randomLevel.rooms[Math.floor(Math.random() * randomLevel.rooms.length)];
                    monster.level = randomLevelName;
                    monster.x = (startRoom.x + Math.floor(startRoom.w / 2)) * TILE_SIZE;
                    monster.y = (startRoom.y + Math.floor(startRoom.h / 2)) * TILE_SIZE;
                }
                monster.status = 'alive'; monster.direction = 'right'; monster.isMonster = true; monster.monsterSpriteIndex = monsterSpriteIndex;
            }

            const initialState = { players: gameState.players, levels: levels, clues: clues, npcs: npcs };
            gameChannel.send({ type: 'broadcast', event: 'init_game_state', payload: initialState });
        });

        // --- 2. GAME LOGIC ---
        async function joinLobby(username) {
            charCreationScreen.style.display = 'none';
            readyRoomScreen.style.display = 'flex';
            uiPanel.style.display = 'flex';
            gameState.gamePhase = 'lobby';
            await startLocalMedia();
            gameState.players[myPlayerId] = { id: myPlayerId, username, isReady: false, isHost: false, spriteStyle: selectedSpriteKey };
            await setupSupabaseChannels();
        }

        function startGame(initialState) {
            if (!initialState) { console.error("Game cannot start without initial state!"); return; }
            
            const lobbyMusic = document.getElementById('lobby-music');
            const dungeonMusic = document.getElementById('dungeon-music');
            lobbyMusic.pause();
            lobbyMusic.currentTime = 0;
            
            dungeonMusic.volume = 0.4;
            if (dungeonMusic.paused) {
                dungeonMusic.play().catch(e => console.error("Dungeon music failed to play:", e));
            }

            gameState.gamePhase = 'playing';
            gameState.players = initialState.players;
            gameState.levels = initialState.levels;
            gameState.clues = initialState.clues;
            gameState.npcs = initialState.npcs;
            readyRoomScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            gameStatusPanel.style.display = 'block';
            initJoystick();
            requestAnimationFrame(gameLoop);
        }

        function initJoystick() {
            const joystickContainer = document.getElementById('joystick-container');
            const joystickThumb = document.getElementById('joystick-thumb');
            if (joystickContainer && joystickThumb) {
                joystick.radius = joystickContainer.offsetWidth / 2;
                joystickContainer.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; }, { passive: false });
                joystickContainer.addEventListener('touchmove', (e) => {
                    if (!joystick.active) return;
                    e.preventDefault();
                    const rect = joystickContainer.getBoundingClientRect();
                    joystick.x = e.touches[0].clientX - rect.left - joystick.radius;
                    joystick.y = e.touches[0].clientY - rect.top - joystick.radius;
                    const mag = Math.sqrt(joystick.x**2 + joystick.y**2);
                    if (mag > joystick.radius) { joystick.x = (joystick.x / mag) * joystick.radius; joystick.y = (joystick.y / mag) * joystick.radius; }
                    joystickThumb.style.transform = `translate(${joystick.x}px, ${joystick.y}px)`;
                    joystick.dx = joystick.x / joystick.radius;
                    joystick.dy = joystick.y / joystick.radius;
                }, { passive: false });
                joystickContainer.addEventListener('touchend', (e) => { e.preventDefault(); joystick.active = false; joystick.dx = 0; joystick.dy = 0; joystickThumb.style.transform = `translate(0px, 0px)`; }, { passive: false });
            }
        }
        
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (gameState.players[myPlayerId]?.isHost) {
                checkDeathTimers();
            }

            if (gameState.gamePhase !== 'playing') {
                if(gameState.gamePhase === 'gameover') {
                    drawGame();
                }
                requestAnimationFrame(gameLoop);
                return;
            }

            if (gameState.players[myPlayerId]?.isHost) {
                updateNpcs(deltaTime);
            }

            const myPlayer = gameState.players[myPlayerId];
            if (!myPlayer || myPlayer.status === 'dead') {
                drawGame(); 
                requestAnimationFrame(gameLoop);
                return;
            }
            
            checkClueCollection();

            if (myPlayer.isMonster) {
                updateMonsterUI();
            } else {
                updateClueCounter(); 
            }
            
            updateMyPlayerPosition(deltaTime);
            checkPlayerCollisions();
            checkResurrection();
            checkStairsUse();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // --- 3. DRAWING & RENDERING ---
        function drawGame() {
            const myPlayer = gameState.players[myPlayerId];
            if (!ctx || !myPlayer || assetsLoadedCount < Object.keys(assets).length) return;
            
            ctx.save();
            ctx.imageSmoothingEnabled = false; 
            ctx.scale(CAMERA_ZOOM, CAMERA_ZOOM);
            const cameraX = myPlayer.x - (canvas.width / 2 / CAMERA_ZOOM);
            const cameraY = myPlayer.y - (canvas.height / 2 / CAMERA_ZOOM);
            ctx.translate(-cameraX, -cameraY);
            ctx.fillStyle = '#111827';
            ctx.fillRect(Math.floor(cameraX), Math.floor(cameraY), Math.ceil(canvas.width / CAMERA_ZOOM), Math.ceil(canvas.height / CAMERA_ZOOM));
            if (!gameState.levels[myPlayer.level]) { ctx.restore(); return; }
            drawLevel(myPlayer.level, cameraX, cameraY);
            drawClues(myPlayer.level);
            drawNpcs();
            
            Object.values(gameState.players).forEach(player => {
                if (player.status === 'alive' && player.level === myPlayer.level) {
                    drawPlayer(player);
                }
            });

            drawTombstones();
            ctx.restore();
            drawFogOfWar();
            drawMinimap();
        }
        
        function drawTombstones() {
            const myPlayer = gameState.players[myPlayerId];
            Object.values(gameState.players).forEach(player => {
                if (player.status === 'dead' && player.level === myPlayer.level) {
                    ctx.drawImage(assets.scenery, tombstoneSprite.sx, tombstoneSprite.sy, SPRITE_SIZE, SPRITE_SIZE, player.x - TILE_SIZE / 2, player.y - TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
                }
            });
        }

        function drawNpcs() {
            const myPlayer = gameState.players[myPlayerId];
            if (!gameState.npcs) return;
            gameState.npcs.forEach(npc => {
                if (npc.level === myPlayer.level) {
                    const { sprite } = npc;
                    const spritesheet = assets[sprite.sheet];
                    ctx.save();
                    ctx.translate(Math.floor(npc.x), Math.floor(npc.y));
                    if (npc.direction === 'left') {
                        ctx.scale(-1, 1);
                    }
                    ctx.drawImage(spritesheet, sprite.sx, sprite.sy, SPRITE_SIZE, SPRITE_SIZE, -TILE_SIZE/2, -TILE_SIZE/2, TILE_SIZE, TILE_SIZE);
                    ctx.restore();
                }
            });
        }

        function drawFogOfWar() {
            const me = gameState.players[myPlayerId];
            if (!me || (!me.isMonster && !me.hasWeapon)) return;
            ctx.save();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width, canvas.height);
            const playerScreenX = canvas.width / 2;
            const playerScreenY = canvas.height / 2;
            ctx.arc(playerScreenX, playerScreenY, SIGHT_RADIUS * TILE_SIZE * CAMERA_ZOOM, 0, Math.PI * 2, true); 
            ctx.fill();
            ctx.restore();
        }
        
        function drawPlayer(player) {
            let spriteInfo, spritesheet, sWidth, sHeight, dWidth, dHeight;
            if (player.isMonster) {
                const monster = giantSprites[player.monsterSpriteIndex];
                if (!monster) {
                    console.error("Invalid monsterSpriteIndex for player:", player);
                    return; 
                }
                spriteInfo = {sx: monster.sx, sy: monster.sy};
                spritesheet = assets[monster.sheet];
                sWidth = monster.sWidth;
                sHeight = monster.sHeight;
                dWidth = TILE_SIZE * 1.5;
                dHeight = TILE_SIZE * 1.5;
            } else {
                spriteInfo = sprites[player.spriteStyle];
                spritesheet = assets.chars;
                sWidth = SPRITE_SIZE;
                sHeight = SPRITE_SIZE;
                dWidth = TILE_SIZE;
                dHeight = TILE_SIZE;
            }
            if (!spriteInfo || !spritesheet) { console.warn("Could not find sprite for style:", player.spriteStyle); return; };
            ctx.save();
            ctx.translate(Math.floor(player.x), Math.floor(player.y));
            if (player.direction === 'left') { ctx.scale(-1, 1); }
            ctx.drawImage(spritesheet, spriteInfo.sx, spriteInfo.sy, sWidth, sHeight, -dWidth / 2, -dHeight / 2, dWidth, dHeight);
            if (player.hasWeapon) {
                ctx.drawImage(assets.items, weaponSprite.sx, weaponSprite.sy, SPRITE_SIZE, SPRITE_SIZE, dWidth / 4, -dHeight / 4, TILE_SIZE, TILE_SIZE);
            }
            ctx.restore();
        }
        
        function drawLevel(levelId, cameraX, cameraY) {
            const level = gameState.levels[levelId];
            if (!level) return;
            const startX = Math.max(0, Math.floor(cameraX / TILE_SIZE));
            const endX = Math.min(MAP_WIDTH, Math.ceil((cameraX + (canvas.width / CAMERA_ZOOM)) / TILE_SIZE) + 1);
            const startY = Math.max(0, Math.floor(cameraY / TILE_SIZE));
            const endY = Math.min(MAP_HEIGHT, Math.ceil((cameraY + (canvas.height / CAMERA_ZOOM)) / TILE_SIZE) + 1);
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const tile = level.grid[y]?.[x];
                    if (!tile) continue;
                    const xPos = x * TILE_SIZE, yPos = y * TILE_SIZE;
                    if (tile.floorVariant) ctx.drawImage(assets.tiles, tile.floorVariant[0] * SPRITE_SIZE, tile.floorVariant[1] * SPRITE_SIZE, SPRITE_SIZE, SPRITE_SIZE, xPos, yPos, TILE_SIZE, TILE_SIZE);
                    if (tile.type !== 'FLOOR') {
                        let [sx, sy] = tileMap[tile.type] || tileMap.WALL_CROSS;
                        ctx.drawImage(assets.tiles, sx * SPRITE_SIZE, sy * SPRITE_SIZE, SPRITE_SIZE, SPRITE_SIZE, xPos, yPos, TILE_SIZE, TILE_SIZE);
                        if (tile.type === 'STAIRS') {
                            ctx.fillStyle = 'white'; ctx.font = `${TILE_SIZE * 0.8}px monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillText(tile.targetLevel, xPos + TILE_SIZE / 2, yPos + TILE_SIZE / 2);
                        }
                    }
                    if (tile.decoration) ctx.drawImage(assets.scenery, tile.decoration.sx, tile.decoration.sy, SPRITE_SIZE, SPRITE_SIZE, xPos, yPos, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        function drawClues(levelId) {
            if (!gameState.clues) return;
            gameState.clues.forEach(clue => {
                if (clue.level === levelId && clue.collectedByTeams.length === 0) { 
                    ctx.drawImage(assets.scenery, clueSprite.sx, clueSprite.sy, SPRITE_SIZE, SPRITE_SIZE, clue.x * TILE_SIZE, clue.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            });
        }

        function drawMinimap() {
            const me = gameState.players[myPlayerId];
            if (!me || !gameState.levels[me.level]) return;
            const level = gameState.levels[me.level];
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            const tileWidth = minimapCanvas.width / MAP_WIDTH, tileHeight = minimapCanvas.height / MAP_HEIGHT;
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const tile = level.grid[y]?.[x];
                    if(!tile) continue;
                    if (tile.type.startsWith('WALL')) minimapCtx.fillStyle = '#6b7280';
                    else if (tile.type === 'FLOOR' || tile.type === 'STAIRS') minimapCtx.fillStyle = '#1f2937';
                    minimapCtx.fillRect(x * tileWidth, y * tileHeight, Math.ceil(tileWidth), Math.ceil(tileHeight));
                }
            }
            minimapCtx.fillStyle = '#a78bfa';
            for (let y = 0; y < MAP_HEIGHT; y++) for (let x = 0; x < MAP_WIDTH; x++) if(level.grid[y]?.[x]?.type === 'STAIRS') minimapCtx.fillRect(x * tileWidth, y * tileHeight, Math.ceil(tileWidth * 2), Math.ceil(tileHeight * 2));
            const playerMapX = (me.x / (MAP_WIDTH * TILE_SIZE)) * minimapCanvas.width;
            const playerMapY = (me.y / (MAP_HEIGHT * TILE_SIZE)) * minimapCanvas.height;
            minimapCtx.fillStyle = 'yellow';
            minimapCtx.beginPath();
            minimapCtx.arc(playerMapX, playerMapY, 3, 0, Math.PI * 2);
            minimapCtx.fill();
        }

        function updatePlayerListUI() {
            if (gameState.gamePhase !== 'lobby' || !playerList) return;
            playerList.innerHTML = '';
            Object.values(gameState.players).forEach(player => {
                const playerEl = document.createElement('div');
                playerEl.className = 'flex items-center justify-between p-2 bg-gray-600 rounded';
                playerEl.innerHTML = `<div class="flex items-center"><canvas class="w-8 h-8 mr-2 bg-gray-800" data-sprite="${player.spriteStyle}"></canvas><span>${player.username} ${player.isHost ? '(Host)' : ''}</span></div><span class="text-2xl">${player.isReady ? '✅' : '❌'}</span>`;
                playerList.appendChild(playerEl);
                const playerCanvas = playerEl.querySelector('canvas');
                playerCanvas.width = 32; playerCanvas.height = 32;
                const pctx = playerCanvas.getContext('2d');
                const spriteInfo = sprites[player.spriteStyle];
                if(spriteInfo && assets.chars.complete) {
                    pctx.imageSmoothingEnabled = false;
                    pctx.drawImage(assets.chars, spriteInfo.sx, spriteInfo.sy, SPRITE_SIZE, SPRITE_SIZE, 0, 0, 32, 32);
                }
            });
        }

        // --- 4. SUPABASE REALTIME ---
        async function setupSupabaseChannels() {
            const channelName = 'mystery-game-' + (new URLSearchParams(window.location.search).get('room') || 'default');
            gameChannel = supabaseClient.channel(channelName, { config: { broadcast: { self: true }, presence: { key: myPlayerId } }});
            gameChannel
                .on('broadcast', { event: 'player_update' }, ({ payload }) => {
                    if (!payload || !payload.id || !gameState.players[payload.id] || payload.id === myPlayerId) return;
                    if (gameState.gamePhase === 'lobby') { 
                        Object.assign(gameState.players[payload.id], payload); 
                        checkHostAndReadyStatus(); 
                    } 
                    else if (gameState.gamePhase === 'playing') {
                        Object.assign(gameState.players[payload.id], payload);
                    }
                })
                .on('broadcast', { event: 'npcs_update' }, ({ payload }) => {
                    if (gameState.gamePhase === 'playing' && !gameState.players[myPlayerId]?.isHost) {
                        gameState.npcs = payload;
                    }
                })
                .on('broadcast', { event: 'init_game_state' }, ({ payload }) => startGame(payload))
                .on('broadcast', { event: 'clue_collected' }, ({ payload }) => {
                    const clue = gameState.clues.find(c => c.id === payload.clueId);
                    if (clue && !clue.collectedByTeams.includes(payload.playerId)) {
                        clue.collectedByTeams.push(payload.playerId);
                    }
                })
                .on('broadcast', { event: 'player_killed' }, ({ payload }) => {
                    const deadPlayer = gameState.players[payload.playerId];
                    if (deadPlayer) {
                        deadPlayer.status = 'dead';
                        deadPlayer.deathTimestamp = Date.now();
                        if (payload.playerId === myPlayerId) {
                            statusText.textContent = 'Status: Dead';
                            gameOverText.textContent = 'You Have Died';
                            gameOverSubtext.textContent = 'A teammate can revive you... but hurry!';
                            gameOverScreen.style.display = 'flex';
                            setTimeout(() => { gameOverScreen.style.display = 'none'; }, 5000);
                        }
                        
                        if (gameState.players[myPlayerId]?.isHost) {
                            checkWinConditions();
                        }
                    }
                })
                .on('broadcast', { event: 'player_resurrected' }, ({ payload }) => {
                    const resurrectedPlayer = gameState.players[payload.playerId];
                    if (resurrectedPlayer) {
                        resurrectedPlayer.status = 'alive';
                        resurrectedPlayer.deathTimestamp = null;
                        if (payload.playerId === myPlayerId) {
                            statusText.textContent = 'Status: Alive';
                            requestAnimationFrame(gameLoop);
                        }
                    }
                })
                .on('broadcast', { event: 'force_turn_monster' }, ({ payload }) => {
                    const player = gameState.players[payload.playerId];
                    if (player && player.status === 'dead') {
                        player.status = 'alive';
                        player.isMonster = true;
                        player.monsterSpriteIndex = payload.monsterSpriteIndex;
                        player.deathTimestamp = null;
                        if (payload.playerId === myPlayerId) {
                            statusText.textContent = 'Status: MONSTER';
                            requestAnimationFrame(gameLoop);
                        }
                        
                        if (gameState.players[myPlayerId]?.isHost) {
                            checkWinConditions();
                        }
                    }
                })
                .on('broadcast', { event: 'monsters_win' }, ({ payload }) => {
                    if (gameState.gamePhase === 'playing') {
                        gameState.gamePhase = 'gameover';
                        document.getElementById('dungeon-music').pause();
                        gameOverText.textContent = payload.title || 'Game Over';
                        gameOverSubtext.textContent = payload.message;
                        gameOverScreen.style.display = 'flex';
                        if (gameState.players[myPlayerId]?.isHost) {
                            playAgainBtn.style.display = 'block';
                        } else {
                            waitingForHostText.style.display = 'block';
                        }
                    }
                })
                .on('broadcast', { event: 'monster_killed' }, ({ payload }) => {
                    if (gameState.gamePhase === 'playing') {
                        gameState.gamePhase = 'gameover';
                        document.getElementById('dungeon-music').pause();
                        gameOverText.textContent = 'Hunters Win!';
                        gameOverSubtext.textContent = `${payload.killerName} defeated the monster!`;
                        gameOverScreen.style.display = 'flex';
                        if (gameState.players[myPlayerId]?.isHost) {
                            playAgainBtn.style.display = 'block';
                        } else {
                            waitingForHostText.style.display = 'block';
                        }
                    }
                })
                .on('broadcast', { event: 'reset_game' }, () => {
                    window.location.reload();
                })
                .on('broadcast', { event: 'chat_message' }, ({ payload }) => {
                    if (payload.senderId === myPlayerId) return;
                    displayChatMessage(payload);
                })
                .on('broadcast', { event: 'webrtc_signal' }, ({ payload }) => handleRtcSignal(payload))
                .on('presence', { event: 'sync' }, () => {
                    const presenceState = gameChannel.presenceState();
                    const newPlayers = {};
                    for (const id in presenceState) {
                        const pInfo = presenceState[id][0]; newPlayers[pInfo.id] = { ...(gameState.players[pInfo.id] || {}), ...pInfo };
                    }
                    if (gameState.players[myPlayerId]) newPlayers[myPlayerId] = gameState.players[myPlayerId];
                    gameState.players = newPlayers;
                    checkHostAndReadyStatus();
                    for (const id in presenceState) {
                        const pres = presenceState[id][0];
                        if (pres.id !== myPlayerId && !peerConnections[pres.id] && myPlayerId < pres.id) {
                            createPeerConnection(pres.id, true);
                        }
                    }
                })
                .on('presence', { event: 'leave' }, ({ leftPresences }) => {
                    leftPresences.forEach(p => {
                        const pId = p.id;
                        if (peerConnections[pId]) { peerConnections[pId].close(); delete peerConnections[pId]; }
                        const videoEl = document.getElementById(`video-container-${pId}`);
                        if (videoEl) videoEl.remove();
                    });
                    updateVideoGridLayout();
                })
                .subscribe(async (status) => { if (status === 'SUBSCRIBED') await gameChannel.track(gameState.players[myPlayerId]); });

            // This loop sends updates at a fixed rate (20 times/sec) to avoid overwhelming the server.
            setInterval(() => {
                if (gameChannel && gameState.players[myPlayerId]) {
                    if (gameState.gamePhase === 'playing') {
                        // Broadcast this player's state
                        broadcastPlayerState();

                        // If this player is the host, also broadcast the NPC states
                        if (gameState.players[myPlayerId].isHost) {
                            gameChannel.send({
                                type: 'broadcast',
                                event: 'npcs_update',
                                payload: gameState.npcs
                            });
                        }
                    }
                }
            }, 50); // 1000ms / 50ms = 20 updates per second
        }

        function checkHostAndReadyStatus() {
            if (!gameChannel) return;
            const presenceState = gameChannel.presenceState();
            const presences = Object.keys(presenceState).sort();
            Object.values(gameState.players).forEach(p => p.isHost = false);
            if (presences.length > 0) {
                const newHostId = presenceState[presences[0]]?.[0]?.id;
                if (newHostId && gameState.players[newHostId]) gameState.players[newHostId].isHost = true;
            }
            const me = gameState.players[myPlayerId];
            if (me && me.isHost) {
                startGameBtn.style.display = 'block';
                const allReady = Object.values(gameState.players).length > 0 && Object.values(gameState.players).every(p => p.isReady);
                startGameBtn.disabled = !allReady;
            } else {
                startGameBtn.style.display = 'none';
            }
            updatePlayerListUI();
        }
        
        function broadcastPlayerState() { if (gameChannel && gameState.players[myPlayerId]) gameChannel.send({ type: 'broadcast', event: 'player_update', payload: gameState.players[myPlayerId] }); }
        function broadcastPlayerKilled(playerId) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'player_killed', payload: { playerId } }); }
        function broadcastMonsterKilled(killerName) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'monster_killed', payload: { killerName } }); }
        function broadcastPlayerResurrected(playerId) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'player_resurrected', payload: { playerId } }); }
        function broadcastForceTurnMonster(playerId, monsterSpriteIndex) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'force_turn_monster', payload: { playerId, monsterSpriteIndex } }); }
        function broadcastClueCollected(clueId, playerId) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'clue_collected', payload: { clueId, playerId } }); }
        function broadcastMonstersWin(title, message) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'monsters_win', payload: { title, message } }); }

        // --- 5. PLAYER MOVEMENT & CONTROLS ---
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        let joystick = { active: false, x: 0, y: 0, dx: 0, dy: 0, radius: 0 };
        window.addEventListener('keydown', (e) => { if (document.activeElement !== chatInput && keys.hasOwnProperty(e.key)) { e.preventDefault(); keys[e.key] = true; } });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });

        function isColliding(x, y, levelGrid) {
            const s = TILE_SIZE / 2 * 0.8; 
            const gx1 = Math.floor((x - s) / TILE_SIZE), gx2 = Math.floor((x + s) / TILE_SIZE);
            const gy1 = Math.floor((y - s) / TILE_SIZE), gy2 = Math.floor((y + s) / TILE_SIZE);
            const check = (gx, gy) => {
                if (gy < 0 || gy >= MAP_HEIGHT || gx < 0 || gx >= MAP_WIDTH) return true;
                const tile = levelGrid[gy]?.[gx];
                return !tile || (tile.type !== 'FLOOR' && tile.type !== 'STAIRS');
            }
            return check(gx1, gy1) || check(gx2, gy1) || check(gx1, gy2) || check(gx2, gy2);
        }

        function updateMyPlayerPosition(deltaTime) {
            const player = gameState.players[myPlayerId];
            if (!player || player.status !== 'alive') return;
            const currentLevel = gameState.levels[player.level];
            if (!currentLevel) return;
            let dx = joystick.active ? joystick.dx : (keys.ArrowRight ? 1 : 0) - (keys.ArrowLeft ? 1 : 0);
            let dy = joystick.active ? joystick.dy : (keys.ArrowDown ? 1 : 0) - (keys.ArrowUp ? 1 : 0);
            const mag = Math.sqrt(dx**2 + dy**2);
            if (mag > 0) {
                const speed = player.isMonster ? MONSTER_SPEED : PLAYER_SPEED;
                const moveX = (dx / mag) * speed * deltaTime;
                const moveY = (dy / mag) * speed * deltaTime;
                if (Math.abs(moveX) > 0.1) player.direction = moveX > 0 ? 'right' : 'left';
                let targetX = player.x + moveX, targetY = player.y + moveY;
                if (isColliding(targetX, targetY, currentLevel.grid)) {
                    if (!isColliding(targetX, player.y, currentLevel.grid)) targetY = player.y;
                    else if (!isColliding(player.x, targetY, currentLevel.grid)) targetX = player.x;
                    else { targetX = player.x; targetY = player.y; }
                }
                player.x = targetX; player.y = targetY;
            }
        }
        
        // --- 6. GAME MECHANICS ---
        function generateLevels() {
            const levels = {}, levelNames = ['A', 'B', 'C'];
            const levelData = {
                A: { rooms: [ {x:5, y:5, w:10, h:8}, {x:20, y:8, w:10, h:10}, {x:40, y:5, w:15, h:10}, {x:45, y:20, w:10, h:10}, {x:5, y:25, w:15, h:15}, {x:30, y:35, w:15, h:10}, {x:25, y:20, w:10, h:10} ] },
                B: { rooms: [ {x:2, y:40, w:15, h:8}, {x:22, y:30, w:11, h:9}, {x:38, y:40, w:10, h:8}, {x:5, y:5, w:12, h:10}, {x:25, y:18, w:12, h:8}, {x:42, y:5, w:15, h:10}, {x:45, y:25, w:10, h:10} ] },
                C: { rooms: [ {x:2, y:2, w:12, h:12}, {x:40, y:5, w:15, h:10}, {x:35, y:35, w:15, h:11}, {x:4, y:30, w:10, h:10}, {x:22, y:22, w:12, h:12}, {x:40, y:20, w:12, h:10}, {x:48, y:30, w:10, h:8} ] }
            };
            levelNames.forEach(levelId => {
                const grid = Array.from({ length: MAP_HEIGHT }, () => Array.from({ length: MAP_WIDTH }, () => ({ type: 'WALL' })));
                const { rooms } = levelData[levelId];
                rooms.forEach(room => { for (let y = room.y; y < room.y + room.h; y++) for (let x = room.x; x < room.x + room.w; x++) if (grid[y]?.[x]) grid[y][x] = { type: 'FLOOR', floorVariant: tileMap.FLOOR_VARS[Math.floor(Math.random() * tileMap.FLOOR_VARS.length)] }; });
                
                for(let i=0; i < rooms.length; i++){
                    connectRooms(rooms[i], rooms[(i + 1) % rooms.length], grid);
                }
                for(let i=0; i < 3; i++) {
                    const roomA = rooms[Math.floor(Math.random() * rooms.length)];
                    const roomB = rooms[Math.floor(Math.random() * rooms.length)];
                    if (roomA !== roomB) {
                        connectRooms(roomA, roomB, grid);
                    }
                }

                for (let y = 0; y < MAP_HEIGHT; y++) for (let x = 0; x < MAP_WIDTH; x++) if (grid[y][x].type === 'WALL' && Math.random() < 0.1) grid[y][x].decoration = scenerySprites[Math.floor(Math.random() * scenerySprites.length)];
                levels[levelId] = { grid, rooms };
            });
            for (let i = 0; i < levelNames.length; i++) {
                const idA = levelNames[i], idB = levelNames[(i + 1) % levelNames.length];
                const rA = levels[idA].rooms[Math.floor(Math.random() * levels[idA].rooms.length)], xA = rA.x + 1 + Math.floor(Math.random()*(rA.w-2)), yA = rA.y + 1 + Math.floor(Math.random()*(rA.h-2)); levels[idA].grid[yA][xA] = { type: 'STAIRS', targetLevel: idB };
                const rB = levels[idB].rooms[Math.floor(Math.random() * levels[idB].rooms.length)], xB = rB.x + 1 + Math.floor(Math.random()*(rB.w-2)), yB = rB.y + 1 + Math.floor(Math.random()*(rB.h-2)); levels[idB].grid[yB][xB] = { type: 'STAIRS', targetLevel: idA };
            }
            return levels;
        }

        function connectRooms(roomA, roomB, grid) {
            const start = { x: Math.floor(roomA.x + roomA.w / 2), y: Math.floor(roomA.y + roomA.h / 2) };
            const end = { x: Math.floor(roomB.x + roomB.w / 2), y: Math.floor(roomB.y + roomB.h / 2) };
            if (Math.random() > 0.5) {
                const h_start = Math.min(start.x, end.x), h_end = Math.max(start.x, end.x);
                for(let x=h_start; x<=h_end; x++) for(let dy=-1; dy<=1; dy++) if(grid[start.y+dy]?.[x]) grid[start.y+dy][x]={type:'FLOOR',floorVariant:tileMap.FLOOR_VARS[0]};
                const v_start = Math.min(start.y, end.y), v_end = Math.max(start.y, end.y);
                for(let y=v_start; y<=v_end; y++) for(let dx=-1; dx<=1; dx++) if(grid[y]?.[end.x+dx]) grid[y][end.x+dx]={type:'FLOOR',floorVariant:tileMap.FLOOR_VARS[0]};
            } else {
                const v_start = Math.min(start.y, end.y), v_end = Math.max(start.y, end.y);
                for(let y=v_start; y<=v_end; y++) for(let dx=-1; dx<=1; dx++) if(grid[y]?.[start.x+dx]) grid[y][start.x+dx]={type:'FLOOR',floorVariant:tileMap.FLOOR_VARS[0]};
                const h_start = Math.min(start.x, end.x), h_end = Math.max(start.x, end.x);
                for(let x=h_start; x<=h_end; x++) for(let dy=-1; dy<=1; dy++) if(grid[end.y+dy]?.[x]) grid[end.y+dy][x]={type:'FLOOR',floorVariant:tileMap.FLOOR_VARS[0]};
            }
        }

        function placeClues(levels, num, dist, pStart) {
            let clues = [], locs = [];
            for (const id in levels) levels[id].rooms.forEach(r => { for (let y=r.y+1; y<r.y+r.h-1; y++) for (let x=r.x+1; x<r.x+r.w-1; x++) if (!(pStart&&id===pStart.level&&x===Math.floor(pStart.x/TILE_SIZE)&&y===Math.floor(pStart.y/TILE_SIZE))&&levels[id].grid[y][x].type==='FLOOR') locs.push({x,y,level:id}); });
            for (let i=locs.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[locs[i],locs[j]]=[locs[j],locs[i]];}
            while(clues.length<num&&locs.length>0){ let loc=locs.pop(); if(!clues.some(c=>c.level===loc.level&&Math.sqrt((c.x-loc.x)**2+(c.y-loc.y)**2)<dist)) clues.push({id:`clue_${clues.length}`,x:loc.x,y:loc.y,level:loc.level,collectedByTeams:[]}); }
            return clues;
        }
        
        function spawnNpcs(levels, count) {
            const npcs = [];
            const levelNames = Object.keys(levels);
            for (let i = 0; i < count; i++) {
                const randomLevelName = levelNames[Math.floor(Math.random() * levelNames.length)];
                const randomLevel = levels[randomLevelName];
                const startRoom = randomLevel.rooms[Math.floor(Math.random() * randomLevel.rooms.length)];
                const sprite = npcMonsterSprites[Math.floor(Math.random() * npcMonsterSprites.length)];
                npcs.push({
                    id: `npc_${i}`, x: (startRoom.x + Math.floor(startRoom.w / 2)) * TILE_SIZE, y: (startRoom.y + Math.floor(startRoom.h / 2)) * TILE_SIZE,
                    level: randomLevelName, sprite: sprite, direction: 'right', moveTimer: Math.random() * 3, moveDirection: {x: 0, y: 0}
                });
            }
            return npcs;
        }

        function updateNpcs(deltaTime) {
            const NPC_SPEED = 150;
            gameState.npcs.forEach(npc => {
                npc.moveTimer -= deltaTime;
                if (npc.moveTimer <= 0) {
                    const roll = Math.random();
                    if (roll < 0.25) npc.moveDirection = { x: 1, y: 0 }; else if (roll < 0.5) npc.moveDirection = { x: -1, y: 0 };
                    else if (roll < 0.75) npc.moveDirection = { x: 0, y: 1 }; else npc.moveDirection = { x: 0, y: -1 };
                    npc.moveTimer = Math.random() * 3 + 2;
                }
                const moveX = npc.moveDirection.x * NPC_SPEED * deltaTime; const moveY = npc.moveDirection.y * NPC_SPEED * deltaTime;
                if (moveX > 0) npc.direction = 'right'; if (moveX < 0) npc.direction = 'left';
                const targetX = npc.x + moveX; const targetY = npc.y + moveY;
                if (!isColliding(targetX, targetY, gameState.levels[npc.level].grid)) {
                    npc.x = targetX; npc.y = targetY;
                } else {
                    npc.moveTimer = 0;
                }
            });
        }
        
        function checkDeathTimers() {
            const now = Date.now();
            for (const player of Object.values(gameState.players)) {
                if (player.status === 'dead' && player.deathTimestamp) {
                    if (now - player.deathTimestamp > DEATH_TIMER_DURATION) {
                        player.deathTimestamp = null;
                        const newMonsterSpriteIndex = Math.floor(Math.random() * giantSprites.length);
                        broadcastForceTurnMonster(player.id, newMonsterSpriteIndex);
                    }
                }
            }
        }

        function checkWinConditions() {
            if (gameState.gamePhase !== 'playing') return;
            
            const allPlayers = Object.values(gameState.players);
            if (allPlayers.length === 0) return;
            
            const livingPlayers = allPlayers.filter(p => p.status === 'alive');
            const livingHunters = allPlayers.filter(p => !p.isMonster && p.status === 'alive');

            if (livingHunters.length === 0 && livingPlayers.length > 0) {
                const allTransformed = livingPlayers.every(p => p.isMonster);
                if (allTransformed && allPlayers.length > 1) {
                    broadcastMonstersWin("Game Over", "You and your comrades have forever become part of the dungeon.");
                } else {
                    broadcastMonstersWin("Monsters Win!", "All hunters have been eliminated.");
                }
            }
        }
        
        function checkResurrection() {
            const me = gameState.players[myPlayerId];
            if (!me || me.status !== 'alive' || me.isMonster) return;
            for (const otherId in gameState.players) {
                if (otherId === myPlayerId) continue;
                const other = gameState.players[otherId];
                if (other.status === 'dead' && other.level === me.level) {
                    const dist = Math.sqrt((me.x - other.x)**2 + (me.y - other.y)**2);
                    if (dist < TILE_SIZE * 0.8) {
                        broadcastPlayerResurrected(otherId);
                    }
                }
            }
        }

        function checkClueCollection() { 
            const p = gameState.players[myPlayerId];
            if(!p || !gameState.clues || p.isMonster) return;
            const px = Math.floor(p.x/TILE_SIZE), py = Math.floor(p.y/TILE_SIZE);
            gameState.clues.forEach(c => {if(c.level===p.level&&c.x===px&&c.y===py&&c.collectedByTeams.length===0){broadcastClueCollected(c.id, p.id);}}); 
        }

        function checkPlayerCollisions() { 
            const me = gameState.players[myPlayerId];
            if(!me || me.status !== 'alive') return;
            for(const oId in gameState.players){
                if(oId === myPlayerId) continue;
                const o = gameState.players[oId];
                if(o.status !== 'alive' || o.level !== me.level) continue;
                if(Math.sqrt((me.x - o.x)**2 + (me.y - o.y)**2) < TILE_SIZE * 0.7){
                    if(me.hasWeapon && o.isMonster) {
                        // FIX 1: Instead of broadcasting, just change the state. The loop will send it.
                        o.status = 'dead'; 
                        broadcastMonsterKilled(me.username);
                    }
                    if(me.isMonster && !o.isMonster) {
                        // FIX 1: Just change the state locally. The loop will broadcast it.
                        o.status = 'dead'; 
                    }
                }
            }
        }

        function checkStairsUse() {
            const player = gameState.players[myPlayerId];
            if (!player) return;

            const now = Date.now();
            if (player.lastStairsUse && now - player.lastStairsUse < 500) {
                return;
            }

            const playerTileX = Math.floor(player.x / TILE_SIZE);
            const playerTileY = Math.floor(player.y / TILE_SIZE);
            const currentTile = gameState.levels[player.level]?.grid[playerTileY]?.[playerTileX];

            if (currentTile && currentTile.type === 'STAIRS') {
                player.lastStairsUse = now;
                const currentLevelId = player.level;
                const targetLevelId = currentTile.targetLevel;
                player.level = targetLevelId;

                const targetLevel = gameState.levels[targetLevelId];
                let foundExit = false;
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        const targetTile = targetLevel.grid[y]?.[x];
                        if (targetTile && targetTile.type === 'STAIRS' && targetTile.targetLevel === currentLevelId) {
                            player.x = (x + 0.5) * TILE_SIZE;
                            player.y = (y + 0.5) * TILE_SIZE;
                            foundExit = true;
                            break;
                        }
                    }
                    if (foundExit) break;
                }
                // FIX 1: Removed broadcastPlayerState(). The update will be sent by the main setInterval loop.
            }
        }
        
        function updateClueCounter() {
            if (!gameState.clues) return;
            const me = gameState.players[myPlayerId];
            if (!me) return;

            const collectedCount = gameState.clues.filter(c => c.collectedByTeams.length > 0).length;
            cluesText.textContent = `Chests Found: ${collectedCount}/${NUM_CLUES}`;

            if (collectedCount >= NUM_CLUES && !me.hasWeapon) {
                me.hasWeapon = true;
                // This is a one-time event, so an immediate broadcast is okay here.
                broadcastPlayerState();
            }
        }
        
        function updateMonsterUI() {
            if (!gameState.clues) return;
            
            const totalChestsCollected = gameState.clues.filter(c => c.collectedByTeams.length > 0).length;

            cluesText.textContent = `Threat Level: ${totalChestsCollected}/${NUM_CLUES}`;
            statusText.textContent = 'Status: Hunting';
        }
        
        // --- 7. WEBRTC & 8. CHAT ---
        async function startLocalMedia() { 
            const lobbyMusic = document.getElementById('lobby-music');
            try { 
                localStream=await navigator.mediaDevices.getUserMedia({
                    video:true,
                    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                });
                createVideoElement(myPlayerId, localStream, "YOU (Me)", true);
                updateVideoGridLayout();
                isMicOn=false;isCamOn=false;
                localStream.getAudioTracks().forEach(t=>t.enabled=isMicOn);
                localStream.getVideoTracks().forEach(t=>t.enabled=isCamOn);
                updateMediaButtons(); 
            } catch(e){
                console.error("Error accessing media devices.",e);
            } finally {
                if (lobbyMusic && lobbyMusic.paused) {
                    lobbyMusic.play().catch(err => {});
                }
            }
        }
        function updateMediaButtons() { micOnIcon.classList.toggle('hidden',!isMicOn);micOffIcon.classList.toggle('hidden',isMicOn);toggleMicBtn.classList.toggle('bg-green-600',isMicOn);toggleMicBtn.classList.toggle('bg-red-600',!isMicOn);camOnIcon.classList.toggle('hidden',!isCamOn);camOffIcon.classList.toggle('hidden',isCamOn);toggleCamBtn.classList.toggle('bg-green-600',isCamOn);toggleCamBtn.classList.toggle('bg-red-600',!isCamOn); }
        toggleMicBtn.addEventListener('click', () => { isMicOn=!isMicOn; if(localStream)localStream.getAudioTracks().forEach(t=>t.enabled=isMicOn);updateMediaButtons(); });
        toggleCamBtn.addEventListener('click', () => { isCamOn=!isCamOn; if(localStream)localStream.getVideoTracks().forEach(t=>t.enabled=isCamOn);updateMediaButtons(); });
        
        function createVideoElement(playerId, stream, username, isMuted = false) {
            let videoContainer = document.getElementById(`video-container-${playerId}`);
            if (videoContainer) return;
            videoContainer = document.createElement('div');
            videoContainer.id = `video-container-${playerId}`;
            videoContainer.className = 'relative bg-gray-700 rounded-md overflow-hidden';
            const videoElement = document.createElement('video');
            videoElement.autoplay = true; videoElement.playsInline = true; videoElement.muted = isMuted;
            videoElement.className = 'w-full h-full object-cover';
            videoElement.srcObject = stream;
            const nameOverlay = document.createElement('div');
            nameOverlay.className = 'absolute bottom-1 left-1 bg-black/50 text-white text-xs px-1 rounded';
            nameOverlay.textContent = username;
            videoContainer.append(videoElement, nameOverlay);
            videoStreamsContainer.appendChild(videoContainer);
        }

        function updateVideoGridLayout() {
            const count = Object.keys(gameState.players).length;
            videoStreamsContainer.className = 'grid gap-1 flex-grow';
            if (count <= 1) {
                videoStreamsContainer.classList.add('grid-cols-1');
            } else if (count === 2) {
                videoStreamsContainer.classList.add('grid-cols-2');
            } else {
                videoStreamsContainer.classList.add('grid-cols-2', 'grid-rows-2');
            }
        }
        
        function sendRtcSignal(to, data) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'webrtc_signal', payload: { from: myPlayerId, to, data } }); }
        
        function createPeerConnection(peerId, isInitiator) { 
            if(peerConnections[peerId]||!localStream)return;
            peerConnections[peerId]=new RTCPeerConnection(peerConnectionConfig);
            localStream.getTracks().forEach(t=>peerConnections[peerId].addTrack(t,localStream));
            peerConnections[peerId].onicecandidate=e=>{if(e.candidate)sendRtcSignal(peerId,{ice:e.candidate});};
            peerConnections[peerId].ontrack=e=>{
                createVideoElement(peerId, e.streams[0], gameState.players[peerId]?.username || 'Player');
                updateVideoGridLayout();
            };
            if(isInitiator){peerConnections[peerId].createOffer().then(o=>peerConnections[peerId].setLocalDescription(o)).then(()=>sendRtcSignal(peerId,{sdp:peerConnections[peerId].localDescription}));}
        }
        function handleRtcSignal({ from, to, data }) { 
            if (to !== myPlayerId) return; 
            let pc = peerConnections[from]; 
            if (!pc) { createPeerConnection(from, false); pc = peerConnections[from]; } 
            if (data.sdp) { pc.setRemoteDescription(new RTCSessionDescription(data.sdp)).then(() => { if (data.sdp.type === 'offer') { pc.createAnswer().then(a => pc.setLocalDescription(a)).then(() => sendRtcSignal(from, { sdp: pc.localDescription })); } }); } 
            else if (data.ice) { pc.addIceCandidate(new RTCIceCandidate(data.ice)); } 
        }
        
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && chatInput.value.trim() !== '') {
                if (!gameChannel) return;
                const message = { 
                    username: gameState.players[myPlayerId]?.username || 'Player', 
                    text: chatInput.value.trim(), 
                    color: '#FFFFFF',
                    senderId: myPlayerId
                };
                gameChannel.send({ type: 'broadcast', event: 'chat_message', payload: message });
                displayChatMessage(message);
                chatInput.value = '';
            }
        });

        function displayChatMessage({ username, text, color }) { 
            const msgEl = document.createElement('p'); 
            msgEl.classList.add('mb-1'); 
            const userSpan = document.createElement('span'); 
            userSpan.textContent = `${username}: `; 
            userSpan.style.fontWeight = 'bold'; 
            userSpan.style.color = color; 
            msgEl.appendChild(userSpan); 
            msgEl.append(document.createTextNode(text)); 
            chatMessages.appendChild(msgEl); 
            chatBox.scrollTop = chatBox.scrollHeight; 
        }

        playAgainBtn.addEventListener('click', () => {
            if (gameChannel && gameState.players[myPlayerId]?.isHost) {
                gameChannel.send({ type: 'broadcast', event: 'reset_game', payload: {} });
            }
        });
    </script>
</body>
</html>
