<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>8-Bit Dungeon Mystery</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        body { font-family: 'Courier New', Courier, monospace; }
        #game-canvas, #lobby-preview-canvas { image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        /* Simple focus styles for accessibility and clarity */
        input:focus, button:focus, select:focus { outline: 2px solid #4f46e5; outline-offset: 2px; }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen flex flex-col md:flex-row items-stretch">

    <!-- UI Panel (Left Side on Desktop, Bottom on Mobile) --><div id="ui-panel" class="w-full md:w-72 lg:w-96 bg-gray-800 p-4 flex-col space-y-2 overflow-y-auto order-last md:order-first h-1/3 md:h-full hidden md:flex">
        <!-- Status & Clues --><div id="game-status-panel" class="bg-gray-900/50 p-2 rounded hidden">
            <div id="status-text" class="text-lg">Status: Alive</div>
            <div id="clues-text" class="text-lg">Chests Found: 0/7</div>
        </div>
        
        <!-- Video Streams --><div class="flex space-x-2">
            <div class="w-1/2 relative aspect-square">
                <video id="local-video" autoplay muted playsinline class="w-full h-full object-cover bg-gray-700 rounded-md border-2 border-gray-500"></video>
                <div id="local-video-overlay" class="absolute inset-0 flex items-center justify-center bg-black/50 text-xs font-bold">YOU</div>
            </div>
            <div id="remote-videos-container" class="w-1/2 bg-gray-700 rounded-md flex items-center justify-center text-sm relative overflow-hidden aspect-square">
                <span id="remote-video-placeholder">Teammate</span>
            </div>
        </div>

         <!-- Video Controls --><div class="flex justify-center space-x-4">
            <button id="toggle-mic-btn" class="p-3 bg-red-600 rounded-full hover:bg-red-500 text-white transition-colors">
                <svg id="mic-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                </svg>
                <svg id="mic-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M5 5l14 14" />
                </svg>
            </button>
            <button id="toggle-cam-btn" class="p-3 bg-red-600 rounded-full hover:bg-red-500 text-white transition-colors">
                <svg id="cam-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                     <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                </svg>
                <svg id="cam-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                   <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                   <path stroke-linecap="round" stroke-linejoin="round" d="M5 5l14 14" />
                </svg>
            </button>
        </div>

        <!-- Chat Box --><div class="flex flex-col flex-grow min-h-0">
             <div id="chat-box" class="flex-grow bg-black/60 rounded-md p-2 overflow-y-auto text-sm mb-2">
                <div id="chat-messages"></div>
            </div>
            <input id="chat-input" type="text" placeholder="Type a message..." class="w-full bg-gray-700 border-2 border-gray-500 rounded-md p-2 text-sm">
        </div>
    </div>

    <!-- Main Game Container --><div id="game-container" class="relative flex-grow bg-black shadow-lg rounded-lg overflow-hidden">
        
        <!-- Loading Screen --><div id="loading-screen" class="absolute inset-0 bg-gray-900 flex items-center justify-center z-50">
            <div class="text-center">
                <h1 class="text-4xl font-bold mb-4">Dungeon Mystery</h1>
                <p>Loading Assets...</p>
            </div>
        </div>

        <!-- Character Creation Screen --><div id="char-creation-screen" class="absolute inset-0 bg-gray-800 flex items-center justify-center z-40 hidden">
             <div class="text-center p-8 bg-gray-700 rounded-lg shadow-xl w-11/12 max-w-md">
                <h2 class="text-2xl mb-4">Choose Your Hero</h2>
                
                <canvas id="lobby-preview-canvas" width="128" height="128" class="bg-gray-800 mx-auto mb-4 rounded"></canvas>
        
                <div class="mb-4">
                    <label for="sprite-style-select" class="block text-sm font-medium">Class:</label>
                    <select id="sprite-style-select" class="w-full bg-gray-600 border border-gray-500 rounded p-1 text-sm text-white">
                        <option value="red_wizard">Red Wizard</option>
                        <option value="blue_wizard">Blue Wizard</option>
                        <option value="green_wizard">Green Wizard</option>
                        <option value="yellow_wizard">Yellow Wizard</option>
                        <option value="silver_knight">Silver Knight</option>
                        <option value="dark_knight">Dark Knight</option>
                        <option value="ranger">Ranger</option>
                    </select>
                </div>
                
                <input id="username-input" type="text" placeholder="Enter your name" class="text-black p-2 rounded w-full mb-4">
                <button id="join-game-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded w-full">Join Game</button>
            </div>
        </div>

        <!-- Ready Room Screen --><div id="ready-room-screen" class="absolute inset-0 bg-gray-800 flex-col items-center justify-center z-30 hidden p-8">
            <h2 class="text-3xl mb-6">Game Lobby</h2>
            <div id="player-list" class="w-full max-w-lg bg-gray-700 rounded-lg p-4 mb-6 space-y-2">
                <!-- Player entries will be generated here -->
            </div>
            <div class="flex space-x-4">
                <button id="ready-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-6 rounded text-xl">Ready Up</button>
                <button id="start-game-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded text-xl hidden disabled:opacity-50" disabled>Start Game</button>
            </div>
        </div>
        
        <!-- Game Over Screen --><div id="game-over-screen" class="absolute inset-0 bg-black/70 flex-col items-center justify-center z-20 hidden">
            <h2 id="game-over-text" class="text-5xl font-bold text-white mb-4">Game Over</h2>
            <p id="game-over-subtext" class="text-xl text-gray-300"></p>
        </div>


        <!-- Game Screen --><div id="game-screen" class="relative w-full h-full hidden">
            <canvas id="game-canvas" class="w-full h-full"></canvas>
            <canvas id="minimap-canvas" class="absolute top-4 right-4 border-2 border-gray-500 bg-black/50" width="200" height="160"></canvas>

            <!-- Virtual Joystick for Mobile --><div id="joystick-container" class="absolute bottom-10 right-10 w-32 h-32 rounded-full bg-gray-500/30 flex items-center justify-center select-none md:hidden">
                <div id="joystick-thumb" class="w-16 h-16 rounded-full bg-gray-400/50"></div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- 0. SUPABASE & GENERAL SETUP ---
        const SUPABASE_URL = 'https://uypjowqnnostwxmcflnm.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV5cGpvd3Fubm9zdHd4bWNmbG5tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAwMTg3NjksImV4cCI6MjA3NTU5NDc2OX0.iUDDwG-TXg5AZNdXxKViz9JomSGtUgiwGnKcs7GBnaU';
        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

        // DOM Elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const loadingScreen = document.getElementById('loading-screen');
        const charCreationScreen = document.getElementById('char-creation-screen');
        const readyRoomScreen = document.getElementById('ready-room-screen');
        const gameScreen = document.getElementById('game-screen');
        const uiPanel = document.getElementById('ui-panel');
        const gameStatusPanel = document.getElementById('game-status-panel');
        const joinGameBtn = document.getElementById('join-game-btn');
        const readyBtn = document.getElementById('ready-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const playerList = document.getElementById('player-list');
        const usernameInput = document.getElementById('username-input');
        const chatInput = document.getElementById('chat-input');
        const chatBox = document.getElementById('chat-box');
        const chatMessages = document.getElementById('chat-messages');
        const cluesText = document.getElementById('clues-text');
        const statusText = document.getElementById('status-text');
        const localVideo = document.getElementById('local-video');
        const remoteVideosContainer = document.getElementById('remote-videos-container');
        const toggleMicBtn = document.getElementById('toggle-mic-btn');
        const toggleCamBtn = document.getElementById('toggle-cam-btn');
        const micOnIcon = document.getElementById('mic-on-icon');
        const micOffIcon = document.getElementById('mic-off-icon');
        const camOnIcon = document.getElementById('cam-on-icon');
        const camOffIcon = document.getElementById('cam-off-icon');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverText = document.getElementById('game-over-text');
        const gameOverSubtext = document.getElementById('game-over-subtext');
        const lobbyPreviewCanvas = document.getElementById('lobby-preview-canvas');
        const spriteStyleSelect = document.getElementById('sprite-style-select');

        // Game State
        const gameState = { 
            players: {}, 
            levels: {},
            clues: [],
            weapon: { id: 'weapon', x: -1, y: -1, level: null, spawnedForTeam: null },
            gamePhase: 'loading' // loading, lobby, playing
        };
        let myPlayerId = null;
        let gameChannel = null;
        
        // Game Constants
        const TILE_SIZE = 128;
        const SPRITE_SIZE = 128;
        const MAP_WIDTH = 100; 
        const MAP_HEIGHT = 80;
        const NUM_CLUES = 7;
        const MIN_CLUE_DISTANCE = 10;
        const PLAYER_SPEED = 10; 
        const MONSTER_SPEED = 11;
        const SIGHT_RADIUS = 8;
        const CAMERA_ZOOM = 0.5;

        // WebRTC State
        let localStream;
        let peerConnections = {};
        const peerConnectionConfig = { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] };
        let isMicOn = false;
        let isCamOn = false;

        // Asset Loading
        const assets = { tiles: new Image(), chars: new Image(), items: new Image(), monsters: new Image(), scenery: new Image(), giants: new Image() };
        let assetsLoadedCount = 0;
        
        const tileMap = {
            FLOOR_VARS: [[0, 2], [1, 2], [2, 2], [3, 2], [4, 2]],
            WALL_V: [12, 5], WALL_H: [13, 4], WALL_TL: [12, 4],
            WALL_TR: [14, 4], WALL_BL: [12, 6], WALL_BR: [14, 6], WALL_T: [13, 6],
            WALL_B: [13, 5], WALL_L: [14, 5], WALL_R: [12, 5], WALL_CROSS: [13,5],
            STAIRS: [4, 1],
        };

        const sprites = {
            red_wizard: {sx: 0, sy: 0},
            blue_wizard: {sx: 2*SPRITE_SIZE, sy: 0},
            green_wizard: {sx: 1*SPRITE_SIZE, sy: 2*SPRITE_SIZE},
            yellow_wizard: {sx: 3*SPRITE_SIZE, sy: 2*SPRITE_SIZE},
            dark_knight: {sx: 1*SPRITE_SIZE, sy: 3*SPRITE_SIZE}, 
            silver_knight: {sx: 2*SPRITE_SIZE, sy: 3*SPRITE_SIZE}, 
            rogue: {sx: 3*SPRITE_SIZE, sy: 3*SPRITE_SIZE}, 
            ranger: {sx: 2*SPRITE_SIZE, sy: 4*SPRITE_SIZE}
        };
        const monsterSprites = [ 
            {sx: 0, sy: 0, sheet: 'monsters'}, {sx: 1*SPRITE_SIZE, sy: 0, sheet: 'monsters'}, {sx: 2*SPRITE_SIZE, sy: 0, sheet: 'monsters'}, 
            {sx: 3*SPRITE_SIZE, sy: 0, sheet: 'monsters'}, {sx: 0, sy: 1*SPRITE_SIZE, sheet: 'monsters'}, {sx: 1*SPRITE_SIZE, sy: 1*SPRITE_SIZE, sheet: 'monsters'},
            {sx: 0, sy: 0, sheet: 'giants'}, {sx: 1*SPRITE_SIZE, sy: 0, sheet: 'giants'}, {sx: 2*SPRITE_SIZE, sy: 0, sheet: 'giants'}
        ];
        const clueSprite = {sx: 1*SPRITE_SIZE, sy: 0}; 
        const weaponSprite = {sx: 3*SPRITE_SIZE, sy: 1*SPRITE_SIZE}; 
        const scenerySprites = [ {sx: 0, sy: 1*SPRITE_SIZE}, {sx: 2*SPRITE_SIZE, sy: 1*SPRITE_SIZE}, {sx: 4*SPRITE_SIZE, sy: 1*SPRITE_SIZE}, {sx: 0, sy: 2*SPRITE_SIZE}, {sx: 1*SPRITE_SIZE, sy: 2*SPRITE_SIZE} ];

        // --- 1. INITIALIZATION ---
        window.onload = () => initGame();
        window.onresize = () => resizeCanvas();

        function initGame() {
            const assetSources = {
                tiles: 'assets/Tiles8x.png', chars: 'assets/Chars8x.png', items: 'assets/Items8x.png',
                monsters: 'assets/Monsters8x.png', scenery: 'assets/Scenery8x.png', giants: 'assets/Giants8x.png'
            };
            let assetsToLoad = Object.keys(assetSources).length;

            function assetLoaded() {
                assetsLoadedCount++;
                if (assetsLoadedCount === assetsToLoad) {
                    loadingScreen.style.display = 'none';
                    charCreationScreen.style.display = 'flex';
                    setupLobby();
                }
            }

            for (const key in assetSources) {
                assets[key].src = assetSources[key];
                assets[key].onload = assetLoaded;
            }

            resizeCanvas();
        }

        function setupLobby() {
            spriteStyleSelect.addEventListener('change', drawLobbyPreview);
            usernameInput.addEventListener('input', () => {
                usernameInput.style.borderColor = '';
            });
            drawLobbyPreview();
        }

        function drawLobbyPreview() {
            const previewCtx = lobbyPreviewCanvas.getContext('2d');
            const style = spriteStyleSelect.value;
            const spriteInfo = sprites[style];
            
            previewCtx.clearRect(0, 0, lobbyPreviewCanvas.width, lobbyPreviewCanvas.height);
            if (spriteInfo && assets.chars.complete) {
                 previewCtx.drawImage(
                    assets.chars, 
                    spriteInfo.sx, spriteInfo.sy, SPRITE_SIZE, SPRITE_SIZE,
                    0, 0, lobbyPreviewCanvas.width, lobbyPreviewCanvas.height
                );
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            if (!container) return;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if(assetsLoadedCount > 0 && gameState.gamePhase === 'playing') drawGame(); 
        }

        joinGameBtn.addEventListener('click', () => {
            if (assetsLoadedCount < Object.keys(assets).length) return;
            const username = usernameInput.value.trim();
            if (!username) {
                usernameInput.style.borderColor = 'red';
                return;
            }
            myPlayerId = `player_${Date.now()}`;
            joinLobby(username);
        });

        readyBtn.addEventListener('click', () => {
            const me = gameState.players[myPlayerId];
            if (me) {
                me.isReady = !me.isReady;
                readyBtn.textContent = me.isReady ? 'Unready' : 'Ready Up';
                readyBtn.classList.toggle('bg-yellow-500', me.isReady);
                readyBtn.classList.toggle('hover:bg-yellow-400', me.isReady);
                readyBtn.classList.toggle('bg-green-600', !me.isReady);
                readyBtn.classList.toggle('hover:bg-green-500', !me.isReady);
                broadcastPlayerState();
            }
        });

        startGameBtn.addEventListener('click', () => {
            if (gameChannel) {
                gameChannel.send({ type: 'broadcast', event: 'start_game', payload: {} });
            }
        });

        // --- 2. GAME LOGIC ---
        async function joinLobby(username) {
            charCreationScreen.style.display = 'none';
            readyRoomScreen.style.display = 'flex';
            uiPanel.style.display = 'flex';
            gameState.gamePhase = 'lobby';

            await startLocalMedia();

            gameState.players[myPlayerId] = {
                id: myPlayerId, username,
                isReady: false, isHost: false,
                spriteStyle: spriteStyleSelect.value,
            };

            await setupSupabaseChannels();
        }

        function startGame() {
            gameState.gamePhase = 'playing';
            readyRoomScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            gameStatusPanel.style.display = 'block';
            
            // Assign roles and generate level data for all players consistently
            const presences = Object.keys(gameChannel.presenceState()).sort();
            const monsterId = presences[1] ? gameState.players[presenceState[presences[1]][0].player_id]?.id : null;
            const monsterSpriteIndex = Math.floor(Math.random() * monsterSprites.length);

            Object.values(gameState.players).forEach(p => {
                const startRoom = gameState.levels.A.rooms[Math.floor(Math.random() * gameState.levels.A.rooms.length)];
                p.x = (startRoom.x + Math.floor(startRoom.w / 2)) * TILE_SIZE;
                p.y = (startRoom.y + Math.floor(startRoom.h / 2)) * TILE_SIZE;
                p.level = 'A';
                p.status = 'alive';
                p.direction = 'right';
                p.isMonster = p.id === monsterId;
                if(p.isMonster) p.monsterSpriteIndex = monsterSpriteIndex;
            });

            gameState.clues = placeClues(gameState.levels, NUM_CLUES, MIN_CLUE_DISTANCE, gameState.players[myPlayerId]);
            
            gameLoop();
        }

        function gameLoop() {
            if (gameState.gamePhase !== 'playing' || gameState.players[myPlayerId]?.status !== 'alive') {
                return;
            }
            updateMyPlayerPosition();
            checkClueCollection();
            checkWeaponCollection();
            checkPlayerCollisions();
            checkStairsUse();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // --- 3. DRAWING & RENDERING ---
        function drawGame() {
            if (!ctx || !myPlayerId || assetsLoadedCount < Object.keys(assets).length || gameState.gamePhase !== 'playing') return;
            const myPlayer = gameState.players[myPlayerId];
            if (!myPlayer) return;
            
            ctx.save();
            ctx.imageSmoothingEnabled = false; 
            ctx.scale(CAMERA_ZOOM, CAMERA_ZOOM);

            const cameraX = myPlayer.x - (canvas.width / 2 / CAMERA_ZOOM);
            const cameraY = myPlayer.y - (canvas.height / 2 / CAMERA_ZOOM);
            ctx.translate(-cameraX, -cameraY);

            ctx.fillStyle = '#111827';
            ctx.fillRect(Math.floor(cameraX), Math.floor(cameraY), Math.ceil(canvas.width / CAMERA_ZOOM), Math.ceil(canvas.height / CAMERA_ZOOM));
            
            if (!gameState.levels[myPlayer.level]) {
                 ctx.restore();
                 return;
            }

            drawLevel(myPlayer.level, cameraX, cameraY);
            drawClues(myPlayer.level);
            drawWeapon(myPlayer.level);
            
            Object.values(gameState.players).forEach(player => {
                if (player.level === myPlayer.level) {
                    drawPlayer(player);
                }
            });

            ctx.restore();
            
            drawFogOfWar();
            drawMinimap();
        }
        
        function drawFogOfWar() {
            const me = gameState.players[myPlayerId];
            if (!me || (!me.isMonster && !me.hasWeapon)) return;

            ctx.save();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width, canvas.height);
            const playerScreenX = canvas.width / 2;
            const playerScreenY = canvas.height / 2;
            ctx.arc(playerScreenX, playerScreenY, SIGHT_RADIUS * TILE_SIZE * CAMERA_ZOOM, 0, Math.PI * 2, true); 
            ctx.fill();
            ctx.restore();
        }
        
        function drawPlayer(player) {
            let spriteInfo;
            let spritesheet;

            if (player.isMonster) {
                const monster = monsterSprites[player.monsterSpriteIndex];
                spriteInfo = {sx: monster.sx, sy: monster.sy};
                spritesheet = assets[monster.sheet];
            } else {
                 spriteInfo = sprites[player.spriteStyle];
                 spritesheet = assets.chars;
            }
            if (!spriteInfo || !spritesheet) return;

            ctx.save();
            ctx.translate(Math.floor(player.x), Math.floor(player.y));
            
            if (player.direction === 'left') {
                ctx.scale(-1, 1);
            }

            if (player.status === 'dead') {
                ctx.filter = 'grayscale(100%)';
            }
            
            ctx.drawImage(
                spritesheet,
                spriteInfo.sx, spriteInfo.sy, SPRITE_SIZE, SPRITE_SIZE,
                -TILE_SIZE / 2, -TILE_SIZE / 2, TILE_SIZE, TILE_SIZE
            );

            ctx.restore();
        }
        
        function drawLevel(levelId, cameraX, cameraY) {
            const level = gameState.levels[levelId];
            if (!level) return;

            const startX = Math.max(0, Math.floor(cameraX / TILE_SIZE));
            const endX = Math.min(MAP_WIDTH, Math.ceil((cameraX + (canvas.width / CAMERA_ZOOM)) / TILE_SIZE) + 1);
            const startY = Math.max(0, Math.floor(cameraY / TILE_SIZE));
            const endY = Math.min(MAP_HEIGHT, Math.ceil((cameraY + (canvas.height / CAMERA_ZOOM)) / TILE_SIZE) + 1);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const tile = level.grid[y][x];
                    const xPos = x * TILE_SIZE;
                    const yPos = y * TILE_SIZE;
                    
                    if (tile.floorVariant) {
                        ctx.drawImage(assets.tiles, tile.floorVariant[0] * SPRITE_SIZE, tile.floorVariant[1] * SPRITE_SIZE, SPRITE_SIZE, SPRITE_SIZE, xPos, yPos, TILE_SIZE, TILE_SIZE);
                    }
                    
                    if (tile.type !== 'FLOOR') {
                        let [sx, sy] = tileMap[tile.type] || tileMap.WALL_CROSS;
                        ctx.drawImage(assets.tiles, sx * SPRITE_SIZE, sy * SPRITE_SIZE, SPRITE_SIZE, SPRITE_SIZE, xPos, yPos, TILE_SIZE, TILE_SIZE);

                        if (tile.type === 'STAIRS') {
                            ctx.fillStyle = 'white';
                            ctx.font = `${TILE_SIZE * 0.8}px monospace`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(tile.targetLevel, xPos + TILE_SIZE / 2, yPos + TILE_SIZE / 2);
                        }
                    }
                    if (tile.scenery) {
                         ctx.drawImage(assets.scenery, tile.scenery.sx, tile.scenery.sy, SPRITE_SIZE, SPRITE_SIZE, xPos, yPos, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        function drawClues(levelId) {
            const myTeamId = gameState.players[myPlayerId]?.teamId;
            if (!myTeamId) return;

            gameState.clues.forEach(clue => {
                if (clue.level === levelId && !clue.collectedByTeams.includes(myTeamId)) {
                    ctx.drawImage(assets.scenery, clueSprite.sx, clueSprite.sy, SPRITE_SIZE, SPRITE_SIZE, clue.x * TILE_SIZE, clue.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            });
        }
        
        function drawWeapon(levelId) {
            const myTeamId = gameState.players[myPlayerId]?.teamId;
            if (gameState.weapon.spawnedForTeam !== myTeamId || gameState.weapon.level !== levelId) return;

            ctx.drawImage(assets.items, weaponSprite.sx, weaponSprite.sy, SPRITE_SIZE, SPRITE_SIZE, gameState.weapon.x * TILE_SIZE, gameState.weapon.y * TILE_SIZE, TILE_SIZE * 1.5, TILE_SIZE * 1.5);
        }

        function drawMinimap() {
            const me = gameState.players[myPlayerId];
            const level = gameState.levels[me.level];
            if (!me || !level) return;

            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            const tileWidth = minimapCanvas.width / MAP_WIDTH;
            const tileHeight = minimapCanvas.height / MAP_HEIGHT;

            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const tile = level.grid[y][x];
                    if (tile.type.startsWith('WALL')) {
                        minimapCtx.fillStyle = '#6b7280';
                        minimapCtx.fillRect(x * tileWidth, y * tileHeight, Math.ceil(tileWidth), Math.ceil(tileHeight));
                    } else if (tile.type === 'FLOOR' || tile.type === 'STAIRS') {
                        minimapCtx.fillStyle = '#1f2937';
                        minimapCtx.fillRect(x * tileWidth, y * tileHeight, Math.ceil(tileWidth), Math.ceil(tileHeight));
                    }
                }
            }
            
            // Now draw stairs on top to make them more visible
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                     const tile = level.grid[y][x];
                     if (tile.type === 'STAIRS') {
                        minimapCtx.fillStyle = '#a78bfa'; // Lighter purple for stairs
                        minimapCtx.fillRect(x * tileWidth, y * tileHeight, Math.ceil(tileWidth * 2), Math.ceil(tileHeight * 2)); // Make them 2x2 tiles size for visibility
                    }
                }
            }


            const playerMapX = (me.x / (MAP_WIDTH * TILE_SIZE)) * minimapCanvas.width;
            const playerMapY = (me.y / (MAP_HEIGHT * TILE_SIZE)) * minimapCanvas.height;

            minimapCtx.fillStyle = 'yellow';
            minimapCtx.beginPath();
            minimapCtx.arc(playerMapX, playerMapY, 4, 0, Math.PI * 2); // Increased radius to 4
            minimapCtx.fill();
        }

        // --- 4. SUPABASE REALTIME ---
        async function setupSupabaseChannels() {
             const channelName = 'mystery-game-' + (new URLSearchParams(window.location.search).get('room') || 'default');
             gameChannel = supabaseClient.channel(channelName, { config: { broadcast: { self: false }, presence: { key: myPlayerId } }});

            gameChannel
                .on('broadcast', { event: 'player_update' }, ({ payload }) => { 
                    if (payload.id && gameState.players[payload.id]) {
                        Object.assign(gameState.players[payload.id], payload);
                    } else {
                        gameState.players[payload.id] = payload;
                    }
                    if(gameState.gamePhase === 'lobby') {
                        updatePlayerListUI();
                        checkHostAndReadyStatus();
                    }
                 })
                .on('broadcast', { event: 'start_game' }, () => startGame())
                .on('broadcast', { event: 'assign_monster' }, ({ payload }) => {
                    if (gameState.players[payload.playerId]) {
                        gameState.players[payload.playerId].isMonster = true;
                        gameState.players[payload.playerId].monsterSpriteIndex = payload.monsterSpriteIndex;
                    }
                })
                .on('broadcast', { event: 'clue_update' }, ({ payload }) => {
                    const clue = gameState.clues.find(c => c.id === payload.clueId);
                    if (clue && !clue.collectedByTeams.includes(payload.teamId)) {
                        clue.collectedByTeams.push(payload.teamId);
                    }
                })
                .on('broadcast', { event: 'weapon_spawn' }, ({ payload }) => {
                    if (payload.teamId === gameState.players[myPlayerId]?.teamId) {
                        gameState.weapon.x = payload.x;
                        gameState.weapon.y = payload.y;
                        gameState.weapon.level = payload.level;
                        gameState.weapon.spawnedForTeam = payload.teamId;
                    }
                })
                .on('broadcast', { event: 'weapon_collect' }, ({ payload }) => {
                    if (gameState.players[payload.playerId]) gameState.players[payload.playerId].hasWeapon = true;
                    if (gameState.weapon.spawnedForTeam === payload.teamId) gameState.weapon.spawnedForTeam = null;
                })
                .on('broadcast', { event: 'player_killed' }, ({ payload }) => {
                    const me = gameState.players[myPlayerId];
                    if (gameState.players[payload.playerId]) {
                        gameState.players[payload.playerId].status = 'dead';
                        if (payload.playerId === myPlayerId) {
                            statusText.textContent = 'Status: Dead';
                            gameOverText.textContent = 'You Have Died';
                            gameOverSubtext.textContent = 'The monster got you...';
                            gameOverScreen.style.display = 'flex';
                        }
                    }
                    if (me && me.isMonster) {
                        const hunters = Object.values(gameState.players).filter(p => !p.isMonster && !p.hasWeapon);
                        if (hunters.length > 0 && hunters.every(p => p.status === 'dead')) broadcastMonsterWins();
                    }
                })
                .on('broadcast', { event: 'monster_killed' }, ({ payload }) => {
                    gameOverText.textContent = 'Hunters Win!';
                    gameOverSubtext.textContent = `${payload.killerName} defeated the monster!`;
                    gameOverScreen.style.display = 'flex';
                    if (gameChannel) gameChannel.unsubscribe();
                })
                .on('broadcast', { event: 'monster_wins' }, () => {
                    gameOverText.textContent = 'Monster Wins!';
                    gameOverSubtext.textContent = `All hunters have been eliminated.`;
                    gameOverScreen.style.display = 'flex';
                    if (gameChannel) gameChannel.unsubscribe();
                })
                .on('broadcast', { event: 'chat_message' }, ({ payload }) => displayChatMessage(payload))
                .on('broadcast', { event: 'webrtc_signal' }, ({ payload }) => handleRtcSignal(payload))
                .on('presence', { event: 'sync' }, () => {
                    const presenceState = gameChannel.presenceState();
                    Object.values(presenceState).forEach(presenceArr => {
                        const p = presenceArr[0];
                        if(!gameState.players[p.player_id]) {
                            gameState.players[p.player_id] = p;
                        }
                    });
                    updatePlayerListUI();
                    checkHostAndReadyStatus();

                    for (const id in presenceState) {
                        if (id !== myPlayerId) {
                            const pres = presenceState[id][0];
                             if (!peerConnections[pres.player_id]) createPeerConnection(pres.player_id, true);
                        }
                    }
                })
                .on('presence', { event: 'leave' }, ({ leftPresences }) => {
                    leftPresences.forEach(p => {
                        delete gameState.players[p.player_id];
                        if (peerConnections[p.player_id]) {
                            peerConnections[p.player_id].close();
                            delete peerConnections[p.player_id];
                        }
                        const videoElement = document.getElementById(`video-${p.player_id}`);
                        if (videoElement) videoElement.remove();
                    });
                    updatePlayerListUI();
                    checkHostAndReadyStatus();
                })
                .subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        await gameChannel.track(gameState.players[myPlayerId]);
                    }
                });
        }
        
        function updatePlayerListUI() {
            if (gameState.gamePhase !== 'lobby') return;
            playerList.innerHTML = '';
            Object.values(gameState.players).forEach(player => {
                const playerEl = document.createElement('div');
                playerEl.className = 'flex items-center justify-between p-2 bg-gray-600 rounded';
                playerEl.innerHTML = `
                    <div class="flex items-center">
                        <canvas class="w-8 h-8 mr-2" data-sprite="${player.spriteStyle}"></canvas>
                        <span>${player.username} ${player.isHost ? '(Host)' : ''}</span>
                    </div>
                    <span class="text-2xl">${player.isReady ? '✅' : '❌'}</span>
                `;
                playerList.appendChild(playerEl);
                const playerCanvas = playerEl.querySelector('canvas');
                const pctx = playerCanvas.getContext('2d');
                const spriteInfo = sprites[player.spriteStyle];
                if(spriteInfo && assets.chars.complete) {
                    pctx.imageSmoothingEnabled = false;
                    pctx.drawImage(assets.chars, spriteInfo.sx, spriteInfo.sy, SPRITE_SIZE, SPRITE_SIZE, 0, 0, 32, 32);
                }
            });
        }

        function checkHostAndReadyStatus() {
            const presences = Object.keys(gameChannel.presenceState()).sort();
            if (presences.length > 0) {
                const hostId = gameChannel.presenceState()[presences[0]][0].player_id;
                Object.values(gameState.players).forEach(p => p.isHost = p.id === hostId);
            }

            const me = gameState.players[myPlayerId];
            if (me && me.isHost) {
                startGameBtn.style.display = 'block';
                const allReady = Object.values(gameState.players).every(p => p.isReady);
                startGameBtn.disabled = !allReady;
            } else {
                startGameBtn.style.display = 'none';
            }
             updatePlayerListUI();
        }

        function broadcastPlayerState() { if (gameChannel && gameState.players[myPlayerId]) gameChannel.send({ type: 'broadcast', event: 'player_update', payload: gameState.players[myPlayerId] }); }
        function broadcastClueCollected(clueId, teamId) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'clue_update', payload: { clueId, teamId } }); }
        function broadcastWeaponSpawn(teamId, x, y, level) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'weapon_spawn', payload: { teamId, x, y, level } }); }
        function broadcastWeaponCollect(playerId, teamId) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'weapon_collect', payload: { playerId, teamId } }); }
        function broadcastPlayerKilled(playerId) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'player_killed', payload: { playerId } }); }
        function broadcastMonsterKilled(killerName) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'monster_killed', payload: { killerName } }); }
        function broadcastAssignMonster(playerId, monsterSpriteIndex) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'assign_monster', payload: { playerId, monsterSpriteIndex } }); }
        function broadcastMonsterWins() { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'monster_wins', payload: {} }); }

        // --- 5. PLAYER MOVEMENT & CONTROLS ---
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const joystick = { active: false, x: 0, y: 0, dx: 0, dy: 0, radius: document.getElementById('joystick-container').offsetWidth / 2 };
        
        window.addEventListener('keydown', (e) => { if (document.activeElement !== chatInput && keys.hasOwnProperty(e.key)) { e.preventDefault(); keys[e.key] = true; } });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });

        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        joystickContainer.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; });
        joystickContainer.addEventListener('touchmove', (e) => {
            if (!joystick.active) return;
            e.preventDefault();
            const rect = joystickContainer.getBoundingClientRect();
            joystick.x = e.touches[0].clientX - rect.left - joystick.radius;
            joystick.y = e.touches[0].clientY - rect.top - joystick.radius;
            const mag = Math.sqrt(joystick.x**2 + joystick.y**2);
            if (mag > joystick.radius) { joystick.x = (joystick.x / mag) * joystick.radius; joystick.y = (joystick.y / mag) * joystick.radius; }
            joystickThumb.style.transform = `translate(${joystick.x}px, ${joystick.y}px)`;
            joystick.dx = joystick.x / joystick.radius;
            joystick.dy = joystick.y / joystick.radius;
        });
        joystickContainer.addEventListener('touchend', (e) => { e.preventDefault(); joystick.active = false; joystick.dx = 0; joystick.dy = 0; joystickThumb.style.transform = `translate(0px, 0px)`; });

        function isColliding(x, y, levelGrid) {
            const playerSize = TILE_SIZE / 2 * 0.8; 
            const gridX1 = Math.floor((x - playerSize) / TILE_SIZE);
            const gridX2 = Math.floor((x + playerSize) / TILE_SIZE);
            const gridY1 = Math.floor((y - playerSize) / TILE_SIZE);
            const gridY2 = Math.floor((y + playerSize) / TILE_SIZE);

            const check = (gx, gy) => {
                const tile = levelGrid[gy]?.[gx];
                return !tile || (tile.type !== 'FLOOR' && tile.type !== 'STAIRS');
            }

            return check(gridX1, gridY1) || check(gridX2, gridY1) ||
                   check(gridX1, gridY2) || check(gridX2, gridY2);
        }

        function updateMyPlayerPosition() {
            const player = gameState.players[myPlayerId];
            if (!player || player.status !== 'alive') return;
            const currentLevel = gameState.levels[player.level];
            if (!currentLevel) return;

            let dx = joystick.active ? joystick.dx : (keys.ArrowRight ? 1 : 0) - (keys.ArrowLeft ? 1 : 0);
            let dy = joystick.active ? joystick.dy : (keys.ArrowDown ? 1 : 0) - (keys.ArrowUp ? 1 : 0);
            const mag = Math.sqrt(dx**2 + dy**2);
            
            if (mag > 0) {
                const moveSpeed = player.isMonster ? MONSTER_SPEED : PLAYER_SPEED;
                const moveX = (dx / mag) * moveSpeed;
                const moveY = (dy / mag) * moveSpeed;
                
                if (moveX > 0) {
                    player.direction = 'right';
                } else if (moveX < 0) {
                    player.direction = 'left';
                }

                let moved = false;
                
                let newX = player.x + moveX;
                let newY = player.y + moveY;

                // Check X-axis collision
                if (!isColliding(newX, player.y, currentLevel.grid)) {
                    player.x = newX;
                    moved = true;
                }

                // Check Y-axis collision
                if (!isColliding(player.x, newY, currentLevel.grid)) {
                    player.y = newY;
                    moved = true;
                }

                if(moved) broadcastPlayerState();
            }
        }
        
        // --- 6. GAME MECHANICS (LEVELS, CLUES, COMBAT) ---
        function generateLevels() {
            const levels = {};
            const levelData = {
                A: {
                    elevators: [],
                    rooms: [
                        {x:2, y:2, w:12, h:10}, {x:20, y:2, w:10, h:12}, {x:35, y:2, w:15, h:9},
                        {x:4, y:20, w:10, h:10}, {x:40, y:20, w:12, h:12}, {x:20, y:30, w:15, h:10},
                        {x:4, y:35, w:11, h:9}, {x:45, y:35, w:12, h:10}
                    ]
                },
                B: {
                    elevators: [],
                    rooms: [
                        {x:2, y:2, w:15, h:10}, {x:22, y:2, w:11, h:11}, {x:38, y:5, w:10, h:12},
                        {x:5, y:18, w:12, h:12}, {x:25, y:22, w:12, h:10}, {x:42, y:25, w:15, h:12},
                        {x:2, y:35, w:10, h:10}, {x:20, y:38, w:12, h:9}
                    ]
                },
                C: {
                    elevators: [],
                    rooms: [
                         {x:2, y:2, w:12, h:12}, {x:20, y:5, w:10, h:10}, {x:35, y:2, w:15, h:11},
                         {x:4, y:20, w:10, h:10}, {x:22, y:22, w:12, h:12}, {x:40, y:20, w:12, h:10},
                         {x:5, y:35, w:15, h:10}, {x:30, y:38, w:12, h:9}
                    ]
                }
            };

            for (const levelId in levelData) {
                const grid = Array.from({ length: MAP_HEIGHT }, () => Array.from({ length: MAP_WIDTH }, () => ({ type: 'WALL' })));
                const { rooms } = levelData[levelId];

                // Draw rooms
                rooms.forEach(room => {
                    for (let ry = room.y; ry < room.y + room.h; ry++) {
                        for (let rx = room.x; rx < room.x + room.w; rx++) {
                            const floorVar = tileMap.FLOOR_VARS[Math.floor(Math.random() * tileMap.FLOOR_VARS.length)];
                            grid[ry][rx] = { type: 'FLOOR', floorVariant: floorVar };
                        }
                    }
                });

                // Draw corridors (3 tiles wide)
                for(let i = 0; i < rooms.length - 1; i++) {
                    const roomA = rooms[i];
                    const roomB = rooms[i+1];

                    const start = { 
                        x: Math.floor(roomA.x + roomA.w / 2), 
                        y: Math.floor(roomA.y + roomA.h / 2) 
                    };
                    const end = { 
                        x: Math.floor(roomB.x + roomB.w / 2), 
                        y: Math.floor(roomB.y + roomB.h / 2) 
                    };
                    
                    // Horizontal corridor segment
                    const h_start = Math.min(start.x, end.x);
                    const h_end = Math.max(start.x, end.x);
                    for(let x = h_start; x <= h_end; x++) {
                        for(let dy = -1; dy <= 1; dy++) { // 3 tiles wide
                            if (grid[start.y + dy] && grid[start.y + dy][x]) {
                                grid[start.y + dy][x] = { type: 'FLOOR', floorVariant: tileMap.FLOOR_VARS[0] };
                            }
                        }
                    }

                    // Vertical corridor segment
                    const v_start = Math.min(start.y, end.y);
                    const v_end = Math.max(start.y, end.y);
                    for(let y = v_start; y <= v_end; y++) {
                        for(let dx = -1; dx <= 1; dx++) { // 3 tiles wide
                            if (grid[y] && grid[y][end.x + dx]) {
                                grid[y][end.x + dx] = { type: 'FLOOR', floorVariant: tileMap.FLOOR_VARS[0] };
                            }
                        }
                    }
                }

                 // Place elevators dynamically within rooms
                const otherLevels = Object.keys(levelData).filter(id => id !== levelId);
                otherLevels.forEach(targetLevelId => {
                    const availableRooms = [...rooms];
                    if (availableRooms.length > 0) {
                        const randomRoom = availableRooms.splice(Math.floor(Math.random() * availableRooms.length), 1)[0];
                        
                        let elevatorX, elevatorY;
                        const rand = Math.random();
                        if (rand < 0.25) { // Top wall
                            elevatorX = randomRoom.x + 1 + Math.floor(Math.random() * (randomRoom.w - 2));
                            elevatorY = randomRoom.y;
                        } else if (rand < 0.5) { // Bottom wall
                            elevatorX = randomRoom.x + 1 + Math.floor(Math.random() * (randomRoom.w - 2));
                            elevatorY = randomRoom.y + randomRoom.h - 1;
                        } else if (rand < 0.75) { // Left wall
                            elevatorX = randomRoom.x;
                            elevatorY = randomRoom.y + 1 + Math.floor(Math.random() * (randomRoom.h - 2));
                        } else { // Right wall
                            elevatorX = randomRoom.x + randomRoom.w - 1;
                            elevatorY = randomRoom.y + 1 + Math.floor(Math.random() * (randomRoom.h - 2));
                        }
                        
                         if (grid[elevatorY]?.[elevatorX]?.type === 'FLOOR') {
                             grid[elevatorY][elevatorX] = { type: 'STAIRS', targetLevel: targetLevelId };
                             levelData[levelId].elevators.push({ x: elevatorX, y: elevatorY, target: targetLevelId });
                        }
                    }
                });

                // Autotile walls & Place Scenery
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        if (grid[y][x].type === 'WALL') {
                            const isFloor = (nx, ny) => grid[ny]?.[nx]?.type !== 'WALL';
                            const above = isFloor(x, y-1);
                            const below = isFloor(x, y+1);
                            const left = isFloor(x-1, y);
                            const right = isFloor(x+1, y);

                            if (above && !below && right && !left) grid[y][x].type = 'WALL_TL';
                            else if (above && !below && !right && left) grid[y][x].type = 'WALL_TR';
                            else if (!above && below && right && !left) grid[y][x].type = 'WALL_BL';
                            else if (!above && below && !right && left) grid[y][x].type = 'WALL_BR';
                            else if (!above && below) grid[y][x].type = 'WALL_B';
                            else if (above && !below) grid[y][x].type = 'WALL_T';
                            else if (!left && right) grid[y][x].type = 'WALL_R';
                            else if (left && !right) grid[y][x].type = 'WALL_L';
                            else if (above && below) grid[y][x].type = 'WALL_V';
                            else if (left && right) grid[y][x].type = 'WALL_H';

                             if(Math.random() < 0.1) {
                                grid[y][x].scenery = scenerySprites[Math.floor(Math.random() * scenerySprites.length)];
                             }
                        }
                    }
                }
                
                levels[levelId] = { grid, rooms };
            }
            return levels;
        }

        function placeClues(levels, numClues, minDistance, playerStartPos) {
            let clues = [];
            let allPossibleLocations = [];
            for (const levelId in levels) {
                levels[levelId].rooms.forEach(room => {
                    for (let y = room.y + 1; y < room.y + room.h - 1; y++) {
                        for (let x = room.x + 1; x < room.x + room.w - 1; x++) {
                            const isPlayerSpawn = (levelId === playerStartPos.level && x === Math.floor(playerStartPos.x / TILE_SIZE) && y === Math.floor(playerStartPos.y / TILE_SIZE));
                            if (!isPlayerSpawn) {
                                allPossibleLocations.push({ x, y, level: levelId });
                            }
                        }
                    }
                });
            }

            for (let i = allPossibleLocations.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [allPossibleLocations[i], allPossibleLocations[j]] = [allPossibleLocations[j], allPossibleLocations[i]]; }
            
            while (clues.length < numClues && allPossibleLocations.length > 0) {
                let loc = allPossibleLocations.pop();
                let tooCloseOnSameLevel = clues.some(clue => clue.level === loc.level && Math.sqrt((clue.x - loc.x)**2 + (clue.y - loc.y)**2) < minDistance);
                if (!tooCloseOnSameLevel) {
                    clues.push({ 
                        id: `clue_${clues.length}`, x: loc.x, y: loc.y, level: loc.level, collectedByTeams: []
                    });
                }
            }
            return clues;
        }
        
        function spawnWeapon(teamId) {
            let allPossibleLocations = [];
            for (const levelId in gameState.levels) {
                gameState.levels[levelId].rooms.forEach(room => {
                    for (let y = room.y + 1; y < room.y + room.h - 1; y++) {
                        for (let x = room.x + 1; x < room.x + room.w - 1; x++) {
                            allPossibleLocations.push({ x, y, level: levelId });
                        }
                    }
                });
            }
            const loc = allPossibleLocations[Math.floor(Math.random() * allPossibleLocations.length)];
            gameState.weapon = { x: loc.x, y: loc.y, level: loc.level, spawnedForTeam: teamId };
            broadcastWeaponSpawn(teamId, loc.x, loc.y, loc.level);
        }

        function checkClueCollection() {
            const player = gameState.players[myPlayerId]; if(!player) return;
            const playerCellX = Math.floor(player.x / TILE_SIZE); const playerCellY = Math.floor(player.y / TILE_SIZE);
            gameState.clues.forEach(clue => { if (clue.level === player.level && clue.x === playerCellX && clue.y === playerCellY && !clue.collectedByTeams.includes(player.teamId)) { clue.collectedByTeams.push(player.teamId); broadcastClueCollected(clue.id, player.teamId); updateClueCounter(); } });
        }
        
        function checkWeaponCollection() {
            const player = gameState.players[myPlayerId];
            if (!player || player.hasWeapon || gameState.weapon.spawnedForTeam !== player.teamId) return;
            const playerCellX = Math.floor(player.x / TILE_SIZE); const playerCellY = Math.floor(player.y / TILE_SIZE);
            if (gameState.weapon.level === player.level && gameState.weapon.x === playerCellX && gameState.weapon.y === playerCellY) {
                player.hasWeapon = true;
                gameState.weapon.spawnedForTeam = null;
                broadcastWeaponCollect(player.id, player.teamId);
            }
        }
        
        function checkPlayerCollisions() {
            const me = gameState.players[myPlayerId];
            if (!me || me.status !== 'alive') return;
            
            for (const otherId in gameState.players) {
                if (otherId === myPlayerId) continue;
                const other = gameState.players[otherId];
                if (other.status !== 'alive' || other.level !== me.level) continue;

                const dist = Math.sqrt((me.x - other.x)**2 + (me.y - other.y)**2);
                if (dist < TILE_SIZE * 0.8) {
                    if (me.hasWeapon && other.isMonster) broadcastMonsterKilled(me.username);
                    if (me.isMonster && !other.hasWeapon) broadcastPlayerKilled(otherId);
                }
            }
        }

        function checkStairsUse() {
            const player = gameState.players[myPlayerId];
            if (!player) return;

            const now = Date.now();
            if (player.lastStairsUse && now - player.lastStairsUse < 500) { // Half-second cooldown
                return;
            }

            const playerCellX = Math.floor(player.x / TILE_SIZE);
            const playerCellY = Math.floor(player.y / TILE_SIZE);
            const tile = gameState.levels[player.level]?.grid[playerCellY]?.[playerCellX];

            if (tile && tile.type === 'STAIRS') {
                player.lastStairsUse = now;
                const currentLevelId = player.level;
                player.level = tile.targetLevel;
                
                 const targetLevelData = gameState.levels[player.level];
                 let destStairsX, destStairsY;

                 // Find the corresponding stairs on the target level
                 for (let y = 0; y < MAP_HEIGHT; y++) {
                     for (let x = 0; x < MAP_WIDTH; x++) {
                         const targetTile = targetLevelData.grid[y][x];
                         if (targetTile.type === 'STAIRS' && targetTile.targetLevel === currentLevelId) {
                            destStairsX = x;
                            destStairsY = y;
                            break;
                         }
                     }
                     if(destStairsX !== undefined) break;
                 }

                 if (destStairsX !== undefined) {
                     // Find a valid floor tile next to the destination stairs to spawn on
                     const offsets = [{dx: 0, dy: 1}, {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: -1, dy: 0}];
                     for (const offset of offsets) {
                         const spawnX = destStairsX + offset.dx;
                         const spawnY = destStairsY + offset.dy;
                         if(targetLevelData.grid[spawnY]?.[spawnX]?.type === 'FLOOR') {
                             player.x = (spawnX + 0.5) * TILE_SIZE;
                             player.y = (spawnY + 0.5) * TILE_SIZE;
                             broadcastPlayerState();
                             return;
                         }
                     }
                 }
                 
                 // Failsafe spawn if no adjacent floor is found
                 player.x = (MAP_WIDTH / 2) * TILE_SIZE;
                 player.y = (MAP_HEIGHT / 2) * TILE_SIZE;
                 broadcastPlayerState();
            }
        }
        
        function updateClueCounter() {
            const myTeamId = gameState.players[myPlayerId]?.teamId; if (!myTeamId) return;
            const collectedCount = gameState.clues.filter(c => c.collectedByTeams.includes(myTeamId)).length;
            cluesText.textContent = `Chests Found: ${collectedCount}/${NUM_CLUES}`;
            if (collectedCount === NUM_CLUES && !gameState.weapon.spawnedForTeam) {
                spawnWeapon(myTeamId);
            }
        }
        
        // --- 7. WEBRTC (VIDEO/AUDIO CHAT) ---
        async function startLocalMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                localStream.getAudioTracks().forEach(track => track.enabled = isMicOn);
                localStream.getVideoTracks().forEach(track => track.enabled = isCamOn);
            } catch (error) { console.error("Error accessing media devices.", error); }
        }

        toggleMicBtn.addEventListener('click', () => {
            isMicOn = !isMicOn;
            if (localStream) localStream.getAudioTracks().forEach(track => track.enabled = isMicOn);
            micOnIcon.classList.toggle('hidden', !isMicOn);
            micOffIcon.classList.toggle('hidden', isMicOn);
            toggleMicBtn.classList.toggle('bg-green-600', isMicOn);
            toggleMicBtn.classList.toggle('bg-red-600', !isMicOn);
        });

        toggleCamBtn.addEventListener('click', () => {
            isCamOn = !isCamOn;
            if (localStream) localStream.getVideoTracks().forEach(track => track.enabled = isCamOn);
            camOnIcon.classList.toggle('hidden', !isCamOn);
            camOffIcon.classList.toggle('hidden', isCamOn);
            toggleCamBtn.classList.toggle('bg-green-600', isCamOn);
            toggleCamBtn.classList.toggle('bg-red-600', !isCamOn);
        });
        
        function sendRtcSignal(to, data) { if (gameChannel) gameChannel.send({ type: 'broadcast', event: 'webrtc_signal', payload: { from: myPlayerId, to, data } }); }

        function createPeerConnection(peerId, isInitiator) {
            if (peerConnections[peerId]) return;
            peerConnections[peerId] = new RTCPeerConnection(peerConnectionConfig);
            if (localStream) localStream.getTracks().forEach(track => peerConnections[peerId].addTrack(track, localStream));
            peerConnections[peerId].onicecandidate = event => { if (event.candidate) sendRtcSignal(peerId, { ice: event.candidate }); };
            peerConnections[peerId].ontrack = event => {
                let videoElement = document.getElementById(`video-${peerId}`);
                if (!videoElement) {
                    remoteVideosContainer.innerHTML = ''; 
                    videoElement = document.createElement('video');
                    videoElement.id = `video-${peerId}`;
                    videoElement.autoplay = true; videoElement.playsInline = true;
                    videoElement.classList.add('w-full', 'h-full', 'object-cover');
                    remoteVideosContainer.appendChild(videoElement);
                }
                videoElement.srcObject = event.streams[0];
            };
            if (isInitiator) { peerConnections[peerId].createOffer().then(offer => peerConnections[peerId].setLocalDescription(offer)).then(() => sendRtcSignal(peerId, { sdp: peerConnections[peerId].localDescription })); }
        }
        
        function handleRtcSignal({ from, to, data }) {
            if (to !== myPlayerId) return;
            let pc = peerConnections[from];
            if (!pc) { createPeerConnection(from, false); pc = peerConnections[from]; }
            if (data.sdp) { pc.setRemoteDescription(new RTCSessionDescription(data.sdp)).then(() => { if (data.sdp.type === 'offer') { pc.createAnswer().then(answer => pc.setLocalDescription(answer)).then(() => sendRtcSignal(from, { sdp: pc.localDescription })); } }); } 
            else if (data.ice) { pc.addIceCandidate(new RTCIceCandidate(data.ice)); }
        }
        
        // --- 8. CHAT ---
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && chatInput.value.trim() !== '') {
                if (!gameChannel) return;
                const message = { username: gameState.players[myPlayerId]?.username || 'Player', text: chatInput.value.trim(), color: '#FFFFFF' };
                gameChannel.send({ type: 'broadcast', event: 'chat_message', payload: message });
                displayChatMessage(message);
                chatInput.value = '';
            }
        });

        function displayChatMessage({ username, text, color }) {
            const messageEl = document.createElement('p');
            messageEl.classList.add('mb-1');
            const usernameSpan = document.createElement('span');
            usernameSpan.textContent = `${username}: `;
            usernameSpan.style.fontWeight = 'bold';
            usernameSpan.style.color = color;
            messageEl.appendChild(usernameSpan);
            messageEl.append(document.createTextNode(text));
            chatMessages.appendChild(messageEl);
            chatBox.scrollTop = chatBox.scrollHeight;
        }
    </script>
</body>
</html>

